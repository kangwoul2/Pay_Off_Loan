"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/../node_modules/fast-equals/dist/es/index.mjs":
/*!*****************************************************!*\
  !*** ../node_modules/fast-equals/dist/es/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   strictCircularDeepEqual: () => (/* binding */ strictCircularDeepEqual),\n/* harmony export */   strictCircularShallowEqual: () => (/* binding */ strictCircularShallowEqual),\n/* harmony export */   strictDeepEqual: () => (/* binding */ strictDeepEqual),\n/* harmony export */   strictShallowEqual: () => (/* binding */ strictShallowEqual)\n/* harmony export */ });\nconst { getOwnPropertyNames, getOwnPropertySymbols } = Object;\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst { hasOwnProperty } = Object.prototype;\n/**\n * Combine two comparators into a single comparators.\n */ function combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */ function createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n        if (!a || !b || typeof a !== \"object\" || typeof b !== \"object\") {\n            return areItemsEqual(a, b, state);\n        }\n        const { cache } = state;\n        const cachedA = cache.get(a);\n        const cachedB = cache.get(b);\n        if (cachedA && cachedB) {\n            return cachedA === b && cachedB === a;\n        }\n        cache.set(a, b);\n        cache.set(b, a);\n        const result = areItemsEqual(a, b, state);\n        cache.delete(a);\n        cache.delete(b);\n        return result;\n    };\n}\n/**\n * Get the `@@toStringTag` of the value, if it exists.\n */ function getShortTag(value) {\n    return value != null ? value[Symbol.toStringTag] : undefined;\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */ function getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */ const hasOwn = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nObject.hasOwn || ((object, property)=>hasOwnProperty.call(object, property));\n/**\n * Whether the values passed are strictly equal or both NaN.\n */ function sameValueZeroEqual(a, b) {\n    return a === b || !a && !b && a !== a && b !== b;\n}\nconst PREACT_VNODE = \"__v\";\nconst PREACT_OWNER = \"__o\";\nconst REACT_OWNER = \"_owner\";\nconst { getOwnPropertyDescriptor, keys } = Object;\n/**\n * Whether the array buffers are equal in value.\n */ function areArrayBuffersEqual(a, b) {\n    return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));\n}\n/**\n * Whether the arrays are equal in value.\n */ function areArraysEqual(a, b, state) {\n    let index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the dataviews are equal in value.\n */ function areDataViewsEqual(a, b) {\n    return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));\n}\n/**\n * Whether the dates passed are equal in value.\n */ function areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the errors passed are equal in value.\n */ function areErrorsEqual(a, b) {\n    return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;\n}\n/**\n * Whether the functions passed are equal in value.\n */ function areFunctionsEqual(a, b) {\n    return a === b;\n}\n/**\n * Whether the `Map`s are equal in value.\n */ function areMapsEqual(a, b, state) {\n    const size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    const matchedIndices = new Array(size);\n    const aIterable = a.entries();\n    let aResult;\n    let bResult;\n    let index = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        const bIterable = b.entries();\n        let hasMatch = false;\n        let matchIndex = 0;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (matchedIndices[matchIndex]) {\n                matchIndex++;\n                continue;\n            }\n            const aEntry = aResult.value;\n            const bEntry = bResult.value;\n            if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n}\n/**\n * Whether the numbers are equal in value.\n */ const areNumbersEqual = sameValueZeroEqual;\n/**\n * Whether the objects are equal in value.\n */ function areObjectsEqual(a, b, state) {\n    const properties = keys(a);\n    let index = properties.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        if (!isPropertyEqual(a, b, state, properties[index])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */ function areObjectsEqualStrict(a, b, state) {\n    const properties = getStrictProperties(a);\n    let index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n        return false;\n    }\n    let property;\n    let descriptorA;\n    let descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        property = properties[index];\n        if (!isPropertyEqual(a, b, state, property)) {\n            return false;\n        }\n        descriptorA = getOwnPropertyDescriptor(a, property);\n        descriptorB = getOwnPropertyDescriptor(b, property);\n        if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */ function arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */ function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */ function areSetsEqual(a, b, state) {\n    const size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    const matchedIndices = new Array(size);\n    const aIterable = a.values();\n    let aResult;\n    let bResult;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        const bIterable = b.values();\n        let hasMatch = false;\n        let matchIndex = 0;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */ function areTypedArraysEqual(a, b) {\n    let index = a.byteLength;\n    if (b.byteLength !== index || a.byteOffset !== b.byteOffset) {\n        return false;\n    }\n    while(index-- > 0){\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the URL instances are equal in value.\n */ function areUrlsEqual(a, b) {\n    return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;\n}\nfunction isPropertyEqual(a, b, state, property) {\n    if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {\n        return true;\n    }\n    return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);\n}\nconst ARRAY_BUFFER_TAG = \"[object ArrayBuffer]\";\nconst ARGUMENTS_TAG = \"[object Arguments]\";\nconst BOOLEAN_TAG = \"[object Boolean]\";\nconst DATA_VIEW_TAG = \"[object DataView]\";\nconst DATE_TAG = \"[object Date]\";\nconst ERROR_TAG = \"[object Error]\";\nconst MAP_TAG = \"[object Map]\";\nconst NUMBER_TAG = \"[object Number]\";\nconst OBJECT_TAG = \"[object Object]\";\nconst REG_EXP_TAG = \"[object RegExp]\";\nconst SET_TAG = \"[object Set]\";\nconst STRING_TAG = \"[object String]\";\nconst TYPED_ARRAY_TAGS = {\n    \"[object Int8Array]\": true,\n    \"[object Uint8Array]\": true,\n    \"[object Uint8ClampedArray]\": true,\n    \"[object Int16Array]\": true,\n    \"[object Uint16Array]\": true,\n    \"[object Int32Array]\": true,\n    \"[object Uint32Array]\": true,\n    \"[object Float16Array]\": true,\n    \"[object Float32Array]\": true,\n    \"[object Float64Array]\": true,\n    \"[object BigInt64Array]\": true,\n    \"[object BigUint64Array]\": true\n};\nconst URL_TAG = \"[object URL]\";\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toString = Object.prototype.toString;\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */ function createEqualityComparator({ areArrayBuffersEqual, areArraysEqual, areDataViewsEqual, areDatesEqual, areErrorsEqual, areFunctionsEqual, areMapsEqual, areNumbersEqual, areObjectsEqual, arePrimitiveWrappersEqual, areRegExpsEqual, areSetsEqual, areTypedArraysEqual, areUrlsEqual, unknownTagComparators }) {\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */ return function comparator(a, b, state) {\n        // If the items are strictly equal, no need to do a value comparison.\n        if (a === b) {\n            return true;\n        }\n        // If either of the items are nullish and fail the strictly equal check\n        // above, then they must be unequal.\n        if (a == null || b == null) {\n            return false;\n        }\n        const type = typeof a;\n        if (type !== typeof b) {\n            return false;\n        }\n        if (type !== \"object\") {\n            if (type === \"number\") {\n                return areNumbersEqual(a, b, state);\n            }\n            if (type === \"function\") {\n                return areFunctionsEqual(a, b, state);\n            }\n            // If a primitive value that is not strictly equal, it must be unequal.\n            return false;\n        }\n        const constructor = a.constructor;\n        // Checks are listed in order of commonality of use-case:\n        //   1. Common complex object types (plain object, array)\n        //   2. Common data values (date, regexp)\n        //   3. Less-common complex object types (map, set)\n        //   4. Less-common data values (promise, primitive wrappers)\n        // Inherently this is both subjective and assumptive, however\n        // when reviewing comparable libraries in the wild this order\n        // appears to be generally consistent.\n        // Constructors should match, otherwise there is potential for false positives\n        // between class and subclass or custom object and POJO.\n        if (constructor !== b.constructor) {\n            return false;\n        }\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\n        // comparisons are rare, and will be handled in the ultimate fallback, so\n        // we can avoid capturing the string tag.\n        if (constructor === Object) {\n            return areObjectsEqual(a, b, state);\n        }\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n        // the string tag or doing an `instanceof` check.\n        if (Array.isArray(a)) {\n            return areArraysEqual(a, b, state);\n        }\n        // Try to fast-path equality checks for other complex object types in the\n        // same realm to avoid capturing the string tag. Strict equality is used\n        // instead of `instanceof` because it is more performant for the common\n        // use-case. If someone is subclassing a native class, it will be handled\n        // with the string tag comparison.\n        if (constructor === Date) {\n            return areDatesEqual(a, b, state);\n        }\n        if (constructor === RegExp) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (constructor === Map) {\n            return areMapsEqual(a, b, state);\n        }\n        if (constructor === Set) {\n            return areSetsEqual(a, b, state);\n        }\n        // Since this is a custom object, capture the string tag to determing its type.\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n        const tag = toString.call(a);\n        if (tag === DATE_TAG) {\n            return areDatesEqual(a, b, state);\n        }\n        // For RegExp, the properties are not enumerable, and therefore will give false positives if\n        // tested like a standard object.\n        if (tag === REG_EXP_TAG) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (tag === MAP_TAG) {\n            return areMapsEqual(a, b, state);\n        }\n        if (tag === SET_TAG) {\n            return areSetsEqual(a, b, state);\n        }\n        if (tag === OBJECT_TAG) {\n            // The exception for value comparison is custom `Promise`-like class instances. These should\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\n            // it reaches this point then that strict equality comparison has already failed.\n            return typeof a.then !== \"function\" && typeof b.then !== \"function\" && areObjectsEqual(a, b, state);\n        }\n        // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === URL_TAG) {\n            return areUrlsEqual(a, b, state);\n        }\n        // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === ERROR_TAG) {\n            return areErrorsEqual(a, b, state);\n        }\n        // If an arguments tag, it should be treated as a standard object.\n        if (tag === ARGUMENTS_TAG) {\n            return areObjectsEqual(a, b, state);\n        }\n        if (TYPED_ARRAY_TAGS[tag]) {\n            return areTypedArraysEqual(a, b, state);\n        }\n        if (tag === ARRAY_BUFFER_TAG) {\n            return areArrayBuffersEqual(a, b, state);\n        }\n        if (tag === DATA_VIEW_TAG) {\n            return areDataViewsEqual(a, b, state);\n        }\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\n        // types.\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n            return arePrimitiveWrappersEqual(a, b, state);\n        }\n        if (unknownTagComparators) {\n            let unknownTagComparator = unknownTagComparators[tag];\n            if (!unknownTagComparator) {\n                const shortTag = getShortTag(a);\n                if (shortTag) {\n                    unknownTagComparator = unknownTagComparators[shortTag];\n                }\n            }\n            // If the custom config has an unknown tag comparator that matches the captured tag or the\n            // @@toStringTag, it is the source of truth for whether the values are equal.\n            if (unknownTagComparator) {\n                return unknownTagComparator(a, b, state);\n            }\n        }\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n        //     comparison that can be made.\n        //   - For types that can be introspected, but rarely have requirements to be compared\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n        //     use-cases (may be included in a future release, if requested enough).\n        //   - For types that can be introspected but do not have an objective definition of what\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n        // In all cases, these decisions should be reevaluated based on changes to the language and\n        // common development practices.\n        return false;\n    };\n}\n/**\n * Create the configuration object used for building comparators.\n */ function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {\n    let config = {\n        areArrayBuffersEqual,\n        areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n        areDataViewsEqual,\n        areDatesEqual: areDatesEqual,\n        areErrorsEqual: areErrorsEqual,\n        areFunctionsEqual: areFunctionsEqual,\n        areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n        areNumbersEqual: areNumbersEqual,\n        areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n        areRegExpsEqual: areRegExpsEqual,\n        areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n        areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,\n        areUrlsEqual: areUrlsEqual,\n        unknownTagComparators: undefined\n    };\n    if (createCustomConfig) {\n        config = Object.assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n        const areArraysEqual = createIsCircular(config.areArraysEqual);\n        const areMapsEqual = createIsCircular(config.areMapsEqual);\n        const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n        const areSetsEqual = createIsCircular(config.areSetsEqual);\n        config = Object.assign({}, config, {\n            areArraysEqual,\n            areMapsEqual,\n            areObjectsEqual,\n            areSetsEqual\n        });\n    }\n    return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */ function createInternalEqualityComparator(compare) {\n    return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n        return compare(a, b, state);\n    };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */ function createIsEqual({ circular, comparator, createState, equals, strict }) {\n    if (createState) {\n        return function isEqual(a, b) {\n            const { cache = circular ? new WeakMap() : undefined, meta } = createState();\n            return comparator(a, b, {\n                cache,\n                equals,\n                meta,\n                strict\n            });\n        };\n    }\n    if (circular) {\n        return function isEqual(a, b) {\n            return comparator(a, b, {\n                cache: new WeakMap(),\n                equals,\n                meta: undefined,\n                strict\n            });\n        };\n    }\n    const state = {\n        cache: undefined,\n        equals,\n        meta: undefined,\n        strict\n    };\n    return function isEqual(a, b) {\n        return comparator(a, b, state);\n    };\n}\n/**\n * Whether the items passed are deeply-equal in value.\n */ const deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */ const strictDeepEqual = createCustomEqual({\n    strict: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */ const circularDeepEqual = createCustomEqual({\n    circular: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */ const strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */ const shallowEqual = createCustomEqual({\n    createInternalComparator: ()=>sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */ const strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: ()=>sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */ const circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: ()=>sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */ const strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: ()=>sameValueZeroEqual,\n    strict: true\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */ function createCustomEqual(options = {}) {\n    const { circular = false, createInternalComparator: createCustomInternalComparator, createState, strict = false } = options;\n    const config = createEqualityComparatorConfig(options);\n    const comparator = createEqualityComparator(config);\n    const equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);\n    return createIsEqual({\n        circular,\n        comparator,\n        createState,\n        equals,\n        strict\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZXF1YWxzL2Rpc3QvZXMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNLEVBQUVBLG1CQUFtQixFQUFFQyxxQkFBcUIsRUFBRSxHQUFHQztBQUN2RCw2REFBNkQ7QUFDN0QsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0QsT0FBT0UsU0FBUztBQUMzQzs7Q0FFQyxHQUNELFNBQVNDLG1CQUFtQkMsV0FBVyxFQUFFQyxXQUFXO0lBQ2hELE9BQU8sU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7UUFDL0IsT0FBT0wsWUFBWUcsR0FBR0MsR0FBR0MsVUFBVUosWUFBWUUsR0FBR0MsR0FBR0M7SUFDekQ7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTQyxpQkFBaUJDLGFBQWE7SUFDbkMsT0FBTyxTQUFTQyxXQUFXTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSztRQUNsQyxJQUFJLENBQUNGLEtBQUssQ0FBQ0MsS0FBSyxPQUFPRCxNQUFNLFlBQVksT0FBT0MsTUFBTSxVQUFVO1lBQzVELE9BQU9HLGNBQWNKLEdBQUdDLEdBQUdDO1FBQy9CO1FBQ0EsTUFBTSxFQUFFSSxLQUFLLEVBQUUsR0FBR0o7UUFDbEIsTUFBTUssVUFBVUQsTUFBTUUsR0FBRyxDQUFDUjtRQUMxQixNQUFNUyxVQUFVSCxNQUFNRSxHQUFHLENBQUNQO1FBQzFCLElBQUlNLFdBQVdFLFNBQVM7WUFDcEIsT0FBT0YsWUFBWU4sS0FBS1EsWUFBWVQ7UUFDeEM7UUFDQU0sTUFBTUksR0FBRyxDQUFDVixHQUFHQztRQUNiSyxNQUFNSSxHQUFHLENBQUNULEdBQUdEO1FBQ2IsTUFBTVcsU0FBU1AsY0FBY0osR0FBR0MsR0FBR0M7UUFDbkNJLE1BQU1NLE1BQU0sQ0FBQ1o7UUFDYk0sTUFBTU0sTUFBTSxDQUFDWDtRQUNiLE9BQU9VO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU0UsWUFB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Q1ZxQiwwQkFBMEIsSUFBTXJIO0FBQ3BDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTXdILDZCQUE2QlIsa0JBQWtCO0lBQ2pEaEIsVUFBVTtJQUNWcUIsMEJBQTBCLElBQU1ySDtJQUNoQ2tHLFFBQVE7QUFDWjtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTYyxrQkFBa0JTLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLE1BQU0sRUFBRXpCLFdBQVcsS0FBSyxFQUFFcUIsMEJBQTBCSyw4QkFBOEIsRUFBRWQsV0FBVyxFQUFFVixTQUFTLEtBQUssRUFBRyxHQUFHdUI7SUFDckgsTUFBTXRCLFNBQVNKLCtCQUErQjBCO0lBQzlDLE1BQU10QyxhQUFhRix5QkFBeUJrQjtJQUM1QyxNQUFNdEYsU0FBUzZHLGlDQUNUQSwrQkFBK0J2QyxjQUMvQmtCLGlDQUFpQ2xCO0lBQ3ZDLE9BQU93QixjQUFjO1FBQUVYO1FBQVViO1FBQVl5QjtRQUFhL0Y7UUFBUXFGO0lBQU87QUFDN0U7QUFFNk0sQ0FDN00sa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbG9hbi1yZWZpbmFuY2Utc2ltdWxhdG9yLy4uL25vZGVfbW9kdWxlcy9mYXN0LWVxdWFscy9kaXN0L2VzL2luZGV4Lm1qcz85MzI2Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgZ2V0T3duUHJvcGVydHlOYW1lcywgZ2V0T3duUHJvcGVydHlTeW1ib2xzIH0gPSBPYmplY3Q7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG5jb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlO1xuLyoqXG4gKiBDb21iaW5lIHR3byBjb21wYXJhdG9ycyBpbnRvIGEgc2luZ2xlIGNvbXBhcmF0b3JzLlxuICovXG5mdW5jdGlvbiBjb21iaW5lQ29tcGFyYXRvcnMoY29tcGFyYXRvckEsIGNvbXBhcmF0b3JCKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYiwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JBKGEsIGIsIHN0YXRlKSAmJiBjb21wYXJhdG9yQihhLCBiLCBzdGF0ZSk7XG4gICAgfTtcbn1cbi8qKlxuICogV3JhcCB0aGUgcHJvdmlkZWQgYGFyZUl0ZW1zRXF1YWxgIG1ldGhvZCB0byBtYW5hZ2UgdGhlIGNpcmN1bGFyIHN0YXRlLCBhbGxvd2luZ1xuICogZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gYmUgc2FmZWx5IGluY2x1ZGVkIGluIHRoZSBjb21wYXJpc29uIHdpdGhvdXQgY3JlYXRpbmdcbiAqIHN0YWNrIG92ZXJmbG93cy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSXNDaXJjdWxhcihhcmVJdGVtc0VxdWFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzQ2lyY3VsYXIoYSwgYiwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCFhIHx8ICFiIHx8IHR5cGVvZiBhICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVJdGVtc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhY2hlIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgY2FjaGVkQSA9IGNhY2hlLmdldChhKTtcbiAgICAgICAgY29uc3QgY2FjaGVkQiA9IGNhY2hlLmdldChiKTtcbiAgICAgICAgaWYgKGNhY2hlZEEgJiYgY2FjaGVkQikge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEEgPT09IGIgJiYgY2FjaGVkQiA9PT0gYTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZS5zZXQoYSwgYik7XG4gICAgICAgIGNhY2hlLnNldChiLCBhKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXJlSXRlbXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShhKTtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4vKipcbiAqIEdldCB0aGUgYEBAdG9TdHJpbmdUYWdgIG9mIHRoZSB2YWx1ZSwgaWYgaXQgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBnZXRTaG9ydFRhZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogR2V0IHRoZSBwcm9wZXJ0aWVzIHRvIHN0cmljdGx5IGV4YW1pbmUsIHdoaWNoIGluY2x1ZGUgYm90aCBvd24gcHJvcGVydGllcyB0aGF0IGFyZVxuICogbm90IGVudW1lcmFibGUgYW5kIHN5bWJvbCBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRTdHJpY3RQcm9wZXJ0aWVzKG9iamVjdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgb2JqZWN0IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBwYXNzZWQgYXMgYW4gb3duIHByb3BlcnR5LlxuICovXG5jb25zdCBoYXNPd24gPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG5PYmplY3QuaGFzT3duIHx8ICgob2JqZWN0LCBwcm9wZXJ0eSkgPT4gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIHZhbHVlcyBwYXNzZWQgYXJlIHN0cmljdGx5IGVxdWFsIG9yIGJvdGggTmFOLlxuICovXG5mdW5jdGlvbiBzYW1lVmFsdWVaZXJvRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiIHx8ICghYSAmJiAhYiAmJiBhICE9PSBhICYmIGIgIT09IGIpO1xufVxuXG5jb25zdCBQUkVBQ1RfVk5PREUgPSAnX192JztcbmNvbnN0IFBSRUFDVF9PV05FUiA9ICdfX28nO1xuY29uc3QgUkVBQ1RfT1dORVIgPSAnX293bmVyJztcbmNvbnN0IHsgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBrZXlzIH0gPSBPYmplY3Q7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGFycmF5IGJ1ZmZlcnMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVBcnJheUJ1ZmZlcnNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEuYnl0ZUxlbmd0aCA9PT0gYi5ieXRlTGVuZ3RoICYmIGFyZVR5cGVkQXJyYXlzRXF1YWwobmV3IFVpbnQ4QXJyYXkoYSksIG5ldyBVaW50OEFycmF5KGIpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgYXJyYXlzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYSwgYiwgc3RhdGUpIHtcbiAgICBsZXQgaW5kZXggPSBhLmxlbmd0aDtcbiAgICBpZiAoYi5sZW5ndGggIT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XG4gICAgICAgIGlmICghc3RhdGUuZXF1YWxzKGFbaW5kZXhdLCBiW2luZGV4XSwgaW5kZXgsIGluZGV4LCBhLCBiLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgZGF0YXZpZXdzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlRGF0YVZpZXdzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoYS5ieXRlTGVuZ3RoID09PSBiLmJ5dGVMZW5ndGhcbiAgICAgICAgJiYgYXJlVHlwZWRBcnJheXNFcXVhbChuZXcgVWludDhBcnJheShhLmJ1ZmZlciwgYS5ieXRlT2Zmc2V0LCBhLmJ5dGVMZW5ndGgpLCBuZXcgVWludDhBcnJheShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmJ5dGVMZW5ndGgpKSk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGRhdGVzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZURhdGVzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWwoYS5nZXRUaW1lKCksIGIuZ2V0VGltZSgpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgZXJyb3JzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZUVycm9yc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiLm1lc3NhZ2UgJiYgYS5jYXVzZSA9PT0gYi5jYXVzZSAmJiBhLnN0YWNrID09PSBiLnN0YWNrO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBmdW5jdGlvbnMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlRnVuY3Rpb25zRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBgTWFwYHMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVNYXBzRXF1YWwoYSwgYiwgc3RhdGUpIHtcbiAgICBjb25zdCBzaXplID0gYS5zaXplO1xuICAgIGlmIChzaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZWRJbmRpY2VzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGNvbnN0IGFJdGVyYWJsZSA9IGEuZW50cmllcygpO1xuICAgIGxldCBhUmVzdWx0O1xuICAgIGxldCBiUmVzdWx0O1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICB3aGlsZSAoKGFSZXN1bHQgPSBhSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICBpZiAoYVJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiSXRlcmFibGUgPSBiLmVudHJpZXMoKTtcbiAgICAgICAgbGV0IGhhc01hdGNoID0gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaEluZGV4ID0gMDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKChiUmVzdWx0ID0gYkl0ZXJhYmxlLm5leHQoKSkpIHtcbiAgICAgICAgICAgIGlmIChiUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSkge1xuICAgICAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFFbnRyeSA9IGFSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBiRW50cnkgPSBiUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmVxdWFscyhhRW50cnlbMF0sIGJFbnRyeVswXSwgaW5kZXgsIG1hdGNoSW5kZXgsIGEsIGIsIHN0YXRlKVxuICAgICAgICAgICAgICAgICYmIHN0YXRlLmVxdWFscyhhRW50cnlbMV0sIGJFbnRyeVsxXSwgYUVudHJ5WzBdLCBiRW50cnlbMF0sIGEsIGIsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgbnVtYmVycyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmNvbnN0IGFyZU51bWJlcnNFcXVhbCA9IHNhbWVWYWx1ZVplcm9FcXVhbDtcbi8qKlxuICogV2hldGhlciB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBrZXlzKGEpO1xuICAgIGxldCBpbmRleCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgIGlmIChrZXlzKGIpLmxlbmd0aCAhPT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBEZWNyZW1lbnRpbmcgYHdoaWxlYCBzaG93ZWQgZmFzdGVyIHJlc3VsdHMgdGhhbiBlaXRoZXIgaW5jcmVtZW50aW5nIG9yXG4gICAgLy8gZGVjcmVtZW50aW5nIGBmb3JgIGxvb3AgYW5kIHRoYW4gYW4gaW5jcmVtZW50aW5nIGB3aGlsZWAgbG9vcC4gRGVjbGFyYXRpdmVcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxuICAgIC8vIGNvc3Qgb2YgYW5vbnltb3VzIGNhbGxiYWNrcy5cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgaWYgKCFpc1Byb3BlcnR5RXF1YWwoYSwgYiwgc3RhdGUsIHByb3BlcnRpZXNbaW5kZXhdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBpbiB2YWx1ZSB3aXRoIHN0cmljdCBwcm9wZXJ0eSBjaGVja2luZy5cbiAqL1xuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsU3RyaWN0KGEsIGIsIHN0YXRlKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGdldFN0cmljdFByb3BlcnRpZXMoYSk7XG4gICAgbGV0IGluZGV4ID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgaWYgKGdldFN0cmljdFByb3BlcnRpZXMoYikubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwcm9wZXJ0eTtcbiAgICBsZXQgZGVzY3JpcHRvckE7XG4gICAgbGV0IGRlc2NyaXB0b3JCO1xuICAgIC8vIERlY3JlbWVudGluZyBgd2hpbGVgIHNob3dlZCBmYXN0ZXIgcmVzdWx0cyB0aGFuIGVpdGhlciBpbmNyZW1lbnRpbmcgb3JcbiAgICAvLyBkZWNyZW1lbnRpbmcgYGZvcmAgbG9vcCBhbmQgdGhhbiBhbiBpbmNyZW1lbnRpbmcgYHdoaWxlYCBsb29wLiBEZWNsYXJhdGl2ZVxuICAgIC8vIG1ldGhvZHMgbGlrZSBgc29tZWAgLyBgZXZlcnlgIHdlcmUgbm90IHVzZWQgdG8gYXZvaWQgaW5jdXJyaW5nIHRoZSBnYXJiYWdlXG4gICAgLy8gY29zdCBvZiBhbm9ueW1vdXMgY2FsbGJhY2tzLlxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaW5kZXhdO1xuICAgICAgICBpZiAoIWlzUHJvcGVydHlFcXVhbChhLCBiLCBzdGF0ZSwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVzY3JpcHRvckEgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSwgcHJvcGVydHkpO1xuICAgICAgICBkZXNjcmlwdG9yQiA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihiLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICgoZGVzY3JpcHRvckEgfHwgZGVzY3JpcHRvckIpXG4gICAgICAgICAgICAmJiAoIWRlc2NyaXB0b3JBXG4gICAgICAgICAgICAgICAgfHwgIWRlc2NyaXB0b3JCXG4gICAgICAgICAgICAgICAgfHwgZGVzY3JpcHRvckEuY29uZmlndXJhYmxlICE9PSBkZXNjcmlwdG9yQi5jb25maWd1cmFibGVcbiAgICAgICAgICAgICAgICB8fCBkZXNjcmlwdG9yQS5lbnVtZXJhYmxlICE9PSBkZXNjcmlwdG9yQi5lbnVtZXJhYmxlXG4gICAgICAgICAgICAgICAgfHwgZGVzY3JpcHRvckEud3JpdGFibGUgIT09IGRlc2NyaXB0b3JCLndyaXRhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBwcmltaXRpdmUgd3JhcHBlcnMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbChhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSByZWdleHBzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZVJlZ0V4cHNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBgU2V0YHMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVTZXRzRXF1YWwoYSwgYiwgc3RhdGUpIHtcbiAgICBjb25zdCBzaXplID0gYS5zaXplO1xuICAgIGlmIChzaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZWRJbmRpY2VzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGNvbnN0IGFJdGVyYWJsZSA9IGEudmFsdWVzKCk7XG4gICAgbGV0IGFSZXN1bHQ7XG4gICAgbGV0IGJSZXN1bHQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICB3aGlsZSAoKGFSZXN1bHQgPSBhSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICBpZiAoYVJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiSXRlcmFibGUgPSBiLnZhbHVlcygpO1xuICAgICAgICBsZXQgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoSW5kZXggPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAoKGJSZXN1bHQgPSBiSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICAgICAgaWYgKGJSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XVxuICAgICAgICAgICAgICAgICYmIHN0YXRlLmVxdWFscyhhUmVzdWx0LnZhbHVlLCBiUmVzdWx0LnZhbHVlLCBhUmVzdWx0LnZhbHVlLCBiUmVzdWx0LnZhbHVlLCBhLCBiLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIFR5cGVkQXJyYXkgaW5zdGFuY2VzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlVHlwZWRBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgbGV0IGluZGV4ID0gYS5ieXRlTGVuZ3RoO1xuICAgIGlmIChiLmJ5dGVMZW5ndGggIT09IGluZGV4IHx8IGEuYnl0ZU9mZnNldCAhPT0gYi5ieXRlT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XG4gICAgICAgIGlmIChhW2luZGV4XSAhPT0gYltpbmRleF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgVVJMIGluc3RhbmNlcyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZVVybHNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIChhLmhvc3RuYW1lID09PSBiLmhvc3RuYW1lXG4gICAgICAgICYmIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWVcbiAgICAgICAgJiYgYS5wcm90b2NvbCA9PT0gYi5wcm90b2NvbFxuICAgICAgICAmJiBhLnBvcnQgPT09IGIucG9ydFxuICAgICAgICAmJiBhLmhhc2ggPT09IGIuaGFzaFxuICAgICAgICAmJiBhLnVzZXJuYW1lID09PSBiLnVzZXJuYW1lXG4gICAgICAgICYmIGEucGFzc3dvcmQgPT09IGIucGFzc3dvcmQpO1xufVxuZnVuY3Rpb24gaXNQcm9wZXJ0eUVxdWFsKGEsIGIsIHN0YXRlLCBwcm9wZXJ0eSkge1xuICAgIGlmICgocHJvcGVydHkgPT09IFJFQUNUX09XTkVSIHx8IHByb3BlcnR5ID09PSBQUkVBQ1RfT1dORVIgfHwgcHJvcGVydHkgPT09IFBSRUFDVF9WTk9ERSlcbiAgICAgICAgJiYgKGEuJCR0eXBlb2YgfHwgYi4kJHR5cGVvZikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNPd24oYiwgcHJvcGVydHkpICYmIHN0YXRlLmVxdWFscyhhW3Byb3BlcnR5XSwgYltwcm9wZXJ0eV0sIHByb3BlcnR5LCBwcm9wZXJ0eSwgYSwgYiwgc3RhdGUpO1xufVxuXG5jb25zdCBBUlJBWV9CVUZGRVJfVEFHID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbmNvbnN0IEFSR1VNRU5UU19UQUcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcbmNvbnN0IEJPT0xFQU5fVEFHID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuY29uc3QgREFUQV9WSUVXX1RBRyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5jb25zdCBEQVRFX1RBRyA9ICdbb2JqZWN0IERhdGVdJztcbmNvbnN0IEVSUk9SX1RBRyA9ICdbb2JqZWN0IEVycm9yXSc7XG5jb25zdCBNQVBfVEFHID0gJ1tvYmplY3QgTWFwXSc7XG5jb25zdCBOVU1CRVJfVEFHID0gJ1tvYmplY3QgTnVtYmVyXSc7XG5jb25zdCBPQkpFQ1RfVEFHID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5jb25zdCBSRUdfRVhQX1RBRyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuY29uc3QgU0VUX1RBRyA9ICdbb2JqZWN0IFNldF0nO1xuY29uc3QgU1RSSU5HX1RBRyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuY29uc3QgVFlQRURfQVJSQVlfVEFHUyA9IHtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBGbG9hdDE2QXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBCaWdJbnQ2NEFycmF5XSc6IHRydWUsXG4gICAgJ1tvYmplY3QgQmlnVWludDY0QXJyYXldJzogdHJ1ZSxcbn07XG5jb25zdCBVUkxfVEFHID0gJ1tvYmplY3QgVVJMXSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vKipcbiAqIENyZWF0ZSBhIGNvbXBhcmF0b3IgbWV0aG9kIGJhc2VkIG9uIHRoZSB0eXBlLXNwZWNpZmljIGVxdWFsaXR5IGNvbXBhcmF0b3JzIHBhc3NlZC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yKHsgYXJlQXJyYXlCdWZmZXJzRXF1YWwsIGFyZUFycmF5c0VxdWFsLCBhcmVEYXRhVmlld3NFcXVhbCwgYXJlRGF0ZXNFcXVhbCwgYXJlRXJyb3JzRXF1YWwsIGFyZUZ1bmN0aW9uc0VxdWFsLCBhcmVNYXBzRXF1YWwsIGFyZU51bWJlcnNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsLCBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLCBhcmVSZWdFeHBzRXF1YWwsIGFyZVNldHNFcXVhbCwgYXJlVHlwZWRBcnJheXNFcXVhbCwgYXJlVXJsc0VxdWFsLCB1bmtub3duVGFnQ29tcGFyYXRvcnMsIH0pIHtcbiAgICAvKipcbiAgICAgKiBjb21wYXJlIHRoZSB2YWx1ZSBvZiB0aGUgdHdvIG9iamVjdHMgYW5kIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdmFsdWVzXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBhcmF0b3IoYSwgYiwgc3RhdGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGl0ZW1zIGFyZSBzdHJpY3RseSBlcXVhbCwgbm8gbmVlZCB0byBkbyBhIHZhbHVlIGNvbXBhcmlzb24uXG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBlaXRoZXIgb2YgdGhlIGl0ZW1zIGFyZSBudWxsaXNoIGFuZCBmYWlsIHRoZSBzdHJpY3RseSBlcXVhbCBjaGVja1xuICAgICAgICAvLyBhYm92ZSwgdGhlbiB0aGV5IG11c3QgYmUgdW5lcXVhbC5cbiAgICAgICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGE7XG4gICAgICAgIGlmICh0eXBlICE9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZU51bWJlcnNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmVGdW5jdGlvbnNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGlzIG5vdCBzdHJpY3RseSBlcXVhbCwgaXQgbXVzdCBiZSB1bmVxdWFsLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gYS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gQ2hlY2tzIGFyZSBsaXN0ZWQgaW4gb3JkZXIgb2YgY29tbW9uYWxpdHkgb2YgdXNlLWNhc2U6XG4gICAgICAgIC8vICAgMS4gQ29tbW9uIGNvbXBsZXggb2JqZWN0IHR5cGVzIChwbGFpbiBvYmplY3QsIGFycmF5KVxuICAgICAgICAvLyAgIDIuIENvbW1vbiBkYXRhIHZhbHVlcyAoZGF0ZSwgcmVnZXhwKVxuICAgICAgICAvLyAgIDMuIExlc3MtY29tbW9uIGNvbXBsZXggb2JqZWN0IHR5cGVzIChtYXAsIHNldClcbiAgICAgICAgLy8gICA0LiBMZXNzLWNvbW1vbiBkYXRhIHZhbHVlcyAocHJvbWlzZSwgcHJpbWl0aXZlIHdyYXBwZXJzKVxuICAgICAgICAvLyBJbmhlcmVudGx5IHRoaXMgaXMgYm90aCBzdWJqZWN0aXZlIGFuZCBhc3N1bXB0aXZlLCBob3dldmVyXG4gICAgICAgIC8vIHdoZW4gcmV2aWV3aW5nIGNvbXBhcmFibGUgbGlicmFyaWVzIGluIHRoZSB3aWxkIHRoaXMgb3JkZXJcbiAgICAgICAgLy8gYXBwZWFycyB0byBiZSBnZW5lcmFsbHkgY29uc2lzdGVudC5cbiAgICAgICAgLy8gQ29uc3RydWN0b3JzIHNob3VsZCBtYXRjaCwgb3RoZXJ3aXNlIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZmFsc2UgcG9zaXRpdmVzXG4gICAgICAgIC8vIGJldHdlZW4gY2xhc3MgYW5kIHN1YmNsYXNzIG9yIGN1c3RvbSBvYmplY3QgYW5kIFBPSk8uXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBpc1BsYWluT2JqZWN0YCBvbmx5IGNoZWNrcyBhZ2FpbnN0IHRoZSBvYmplY3QncyBvd24gcmVhbG0uIENyb3NzLXJlYWxtXG4gICAgICAgIC8vIGNvbXBhcmlzb25zIGFyZSByYXJlLCBhbmQgd2lsbCBiZSBoYW5kbGVkIGluIHRoZSB1bHRpbWF0ZSBmYWxsYmFjaywgc29cbiAgICAgICAgLy8gd2UgY2FuIGF2b2lkIGNhcHR1cmluZyB0aGUgc3RyaW5nIHRhZy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBpc0FycmF5KClgIHdvcmtzIG9uIHN1YmNsYXNzZXMgYW5kIGlzIGNyb3NzLXJlYWxtLCBzbyB3ZSBjYW4gYXZvaWQgY2FwdHVyaW5nXG4gICAgICAgIC8vIHRoZSBzdHJpbmcgdGFnIG9yIGRvaW5nIGFuIGBpbnN0YW5jZW9mYCBjaGVjay5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVBcnJheXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGZhc3QtcGF0aCBlcXVhbGl0eSBjaGVja3MgZm9yIG90aGVyIGNvbXBsZXggb2JqZWN0IHR5cGVzIGluIHRoZVxuICAgICAgICAvLyBzYW1lIHJlYWxtIHRvIGF2b2lkIGNhcHR1cmluZyB0aGUgc3RyaW5nIHRhZy4gU3RyaWN0IGVxdWFsaXR5IGlzIHVzZWRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBgaW5zdGFuY2VvZmAgYmVjYXVzZSBpdCBpcyBtb3JlIHBlcmZvcm1hbnQgZm9yIHRoZSBjb21tb25cbiAgICAgICAgLy8gdXNlLWNhc2UuIElmIHNvbWVvbmUgaXMgc3ViY2xhc3NpbmcgYSBuYXRpdmUgY2xhc3MsIGl0IHdpbGwgYmUgaGFuZGxlZFxuICAgICAgICAvLyB3aXRoIHRoZSBzdHJpbmcgdGFnIGNvbXBhcmlzb24uXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZURhdGVzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlUmVnRXhwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBTZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVTZXRzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBjdXN0b20gb2JqZWN0LCBjYXB0dXJlIHRoZSBzdHJpbmcgdGFnIHRvIGRldGVybWluZyBpdHMgdHlwZS5cbiAgICAgICAgLy8gVGhpcyBpcyByZWFzb25hYmx5IHBlcmZvcm1hbnQgaW4gbW9kZXJuIGVudmlyb25tZW50cyBsaWtlIHY4IGFuZCBTcGlkZXJNb25rZXkuXG4gICAgICAgIGNvbnN0IHRhZyA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgICAgIGlmICh0YWcgPT09IERBVEVfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlRGF0ZXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIFJlZ0V4cCwgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBlbnVtZXJhYmxlLCBhbmQgdGhlcmVmb3JlIHdpbGwgZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgaWZcbiAgICAgICAgLy8gdGVzdGVkIGxpa2UgYSBzdGFuZGFyZCBvYmplY3QuXG4gICAgICAgIGlmICh0YWcgPT09IFJFR19FWFBfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlUmVnRXhwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBNQVBfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlTWFwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBTRVRfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlU2V0c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBPQkpFQ1RfVEFHKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXhjZXB0aW9uIGZvciB2YWx1ZSBjb21wYXJpc29uIGlzIGN1c3RvbSBgUHJvbWlzZWAtbGlrZSBjbGFzcyBpbnN0YW5jZXMuIFRoZXNlIHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyBzdGFuZGFyZCBgUHJvbWlzZWAgb2JqZWN0cywgd2hpY2ggbWVhbnMgc3RyaWN0IGVxdWFsaXR5LCBhbmQgaWZcbiAgICAgICAgICAgIC8vIGl0IHJlYWNoZXMgdGhpcyBwb2ludCB0aGVuIHRoYXQgc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb24gaGFzIGFscmVhZHkgZmFpbGVkLlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhLnRoZW4gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGIudGhlbiAhPT0gJ2Z1bmN0aW9uJyAmJiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgVVJMIHRhZywgaXQgc2hvdWxkIGJlIHRlc3RlZCBleHBsaWNpdGx5LiBMaWtlIFJlZ0V4cCwgdGhlIHByb3BlcnRpZXMgYXJlIG5vdFxuICAgICAgICAvLyBlbnVtZXJhYmxlLCBhbmQgdGhlcmVmb3JlIHdpbGwgZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgaWYgdGVzdGVkIGxpa2UgYSBzdGFuZGFyZCBvYmplY3QuXG4gICAgICAgIGlmICh0YWcgPT09IFVSTF9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVVcmxzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIGVycm9yIHRhZywgaXQgc2hvdWxkIGJlIHRlc3RlZCBleHBsaWNpdGx5LiBMaWtlIFJlZ0V4cCwgdGhlIHByb3BlcnRpZXMgYXJlIG5vdFxuICAgICAgICAvLyBlbnVtZXJhYmxlLCBhbmQgdGhlcmVmb3JlIHdpbGwgZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgaWYgdGVzdGVkIGxpa2UgYSBzdGFuZGFyZCBvYmplY3QuXG4gICAgICAgIGlmICh0YWcgPT09IEVSUk9SX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUVycm9yc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhbiBhcmd1bWVudHMgdGFnLCBpdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gQVJHVU1FTlRTX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRZUEVEX0FSUkFZX1RBR1NbdGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVR5cGVkQXJyYXlzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IEFSUkFZX0JVRkZFUl9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVBcnJheUJ1ZmZlcnNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gREFUQV9WSUVXX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZURhdGFWaWV3c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB0aGUgcGVudWx0aW1hdGUgZmFsbGJhY2ssIGNoZWNrIGlmIHRoZSB2YWx1ZXMgcGFzc2VkIGFyZSBwcmltaXRpdmUgd3JhcHBlcnMuIFRoaXNcbiAgICAgICAgLy8gaXMgdmVyeSByYXJlIGluIG1vZGVybiBKUywgd2hpY2ggaXMgd2h5IGl0IGlzIGRlcHJpb3JpdGl6ZWQgY29tcGFyZWQgdG8gYWxsIG90aGVyIG9iamVjdFxuICAgICAgICAvLyB0eXBlcy5cbiAgICAgICAgaWYgKHRhZyA9PT0gQk9PTEVBTl9UQUcgfHwgdGFnID09PSBOVU1CRVJfVEFHIHx8IHRhZyA9PT0gU1RSSU5HX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmtub3duVGFnQ29tcGFyYXRvcnMpIHtcbiAgICAgICAgICAgIGxldCB1bmtub3duVGFnQ29tcGFyYXRvciA9IHVua25vd25UYWdDb21wYXJhdG9yc1t0YWddO1xuICAgICAgICAgICAgaWYgKCF1bmtub3duVGFnQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3J0VGFnID0gZ2V0U2hvcnRUYWcoYSk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3J0VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVua25vd25UYWdDb21wYXJhdG9yID0gdW5rbm93blRhZ0NvbXBhcmF0b3JzW3Nob3J0VGFnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgY3VzdG9tIGNvbmZpZyBoYXMgYW4gdW5rbm93biB0YWcgY29tcGFyYXRvciB0aGF0IG1hdGNoZXMgdGhlIGNhcHR1cmVkIHRhZyBvciB0aGVcbiAgICAgICAgICAgIC8vIEBAdG9TdHJpbmdUYWcsIGl0IGlzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHdoZXRoZXIgdGhlIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgICBpZiAodW5rbm93blRhZ0NvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5rbm93blRhZ0NvbXBhcmF0b3IoYSwgYiwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vdCBtYXRjaGluZyBhbnkgdGFncyB0aGF0IHJlcXVpcmUgYSBzcGVjaWZpYyB0eXBlIG9mIGNvbXBhcmlzb24sIHRoZW4gd2UgaGFyZC1jb2RlIGZhbHNlIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIG9ubHkgdGhpbmcgcmVtYWluaW5nIGlzIHN0cmljdCBlcXVhbGl0eSwgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBjb21wYXJlZC4gVGhpcyBpcyBmb3IgYSBmZXcgcmVhc29uczpcbiAgICAgICAgLy8gICAtIENlcnRhaW4gdHlwZXMgdGhhdCBjYW5ub3QgYmUgaW50cm9zcGVjdGVkIChlLmcuLCBgV2Vha01hcGApLiBGb3IgdGhlc2UgdHlwZXMsIHRoaXMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gICAgIGNvbXBhcmlzb24gdGhhdCBjYW4gYmUgbWFkZS5cbiAgICAgICAgLy8gICAtIEZvciB0eXBlcyB0aGF0IGNhbiBiZSBpbnRyb3NwZWN0ZWQsIGJ1dCByYXJlbHkgaGF2ZSByZXF1aXJlbWVudHMgdG8gYmUgY29tcGFyZWRcbiAgICAgICAgLy8gICAgIChgQXJyYXlCdWZmZXJgLCBgRGF0YVZpZXdgLCBldGMuKSwgdGhlIGNvc3QgaXMgYXZvaWRlZCB0byBwcmlvcml0aXplIHRoZSBjb21tb25cbiAgICAgICAgLy8gICAgIHVzZS1jYXNlcyAobWF5IGJlIGluY2x1ZGVkIGluIGEgZnV0dXJlIHJlbGVhc2UsIGlmIHJlcXVlc3RlZCBlbm91Z2gpLlxuICAgICAgICAvLyAgIC0gRm9yIHR5cGVzIHRoYXQgY2FuIGJlIGludHJvc3BlY3RlZCBidXQgZG8gbm90IGhhdmUgYW4gb2JqZWN0aXZlIGRlZmluaXRpb24gb2Ygd2hhdFxuICAgICAgICAvLyAgICAgZXF1YWxpdHkgaXMgKGBFcnJvcmAsIGV0Yy4pLCB0aGUgc3ViamVjdGl2ZSBkZWNpc2lvbiBpcyB0byBiZSBjb25zZXJ2YXRpdmUgYW5kIHN0cmljdGx5IGNvbXBhcmUuXG4gICAgICAgIC8vIEluIGFsbCBjYXNlcywgdGhlc2UgZGVjaXNpb25zIHNob3VsZCBiZSByZWV2YWx1YXRlZCBiYXNlZCBvbiBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBhbmRcbiAgICAgICAgLy8gY29tbW9uIGRldmVsb3BtZW50IHByYWN0aWNlcy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdXNlZCBmb3IgYnVpbGRpbmcgY29tcGFyYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvckNvbmZpZyh7IGNpcmN1bGFyLCBjcmVhdGVDdXN0b21Db25maWcsIHN0cmljdCwgfSkge1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgIGFyZUFycmF5QnVmZmVyc0VxdWFsLFxuICAgICAgICBhcmVBcnJheXNFcXVhbDogc3RyaWN0ID8gYXJlT2JqZWN0c0VxdWFsU3RyaWN0IDogYXJlQXJyYXlzRXF1YWwsXG4gICAgICAgIGFyZURhdGFWaWV3c0VxdWFsLFxuICAgICAgICBhcmVEYXRlc0VxdWFsOiBhcmVEYXRlc0VxdWFsLFxuICAgICAgICBhcmVFcnJvcnNFcXVhbDogYXJlRXJyb3JzRXF1YWwsXG4gICAgICAgIGFyZUZ1bmN0aW9uc0VxdWFsOiBhcmVGdW5jdGlvbnNFcXVhbCxcbiAgICAgICAgYXJlTWFwc0VxdWFsOiBzdHJpY3QgPyBjb21iaW5lQ29tcGFyYXRvcnMoYXJlTWFwc0VxdWFsLCBhcmVPYmplY3RzRXF1YWxTdHJpY3QpIDogYXJlTWFwc0VxdWFsLFxuICAgICAgICBhcmVOdW1iZXJzRXF1YWw6IGFyZU51bWJlcnNFcXVhbCxcbiAgICAgICAgYXJlT2JqZWN0c0VxdWFsOiBzdHJpY3QgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3QgOiBhcmVPYmplY3RzRXF1YWwsXG4gICAgICAgIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWw6IGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwsXG4gICAgICAgIGFyZVJlZ0V4cHNFcXVhbDogYXJlUmVnRXhwc0VxdWFsLFxuICAgICAgICBhcmVTZXRzRXF1YWw6IHN0cmljdCA/IGNvbWJpbmVDb21wYXJhdG9ycyhhcmVTZXRzRXF1YWwsIGFyZU9iamVjdHNFcXVhbFN0cmljdCkgOiBhcmVTZXRzRXF1YWwsXG4gICAgICAgIGFyZVR5cGVkQXJyYXlzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBjb21iaW5lQ29tcGFyYXRvcnMoYXJlVHlwZWRBcnJheXNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsU3RyaWN0KVxuICAgICAgICAgICAgOiBhcmVUeXBlZEFycmF5c0VxdWFsLFxuICAgICAgICBhcmVVcmxzRXF1YWw6IGFyZVVybHNFcXVhbCxcbiAgICAgICAgdW5rbm93blRhZ0NvbXBhcmF0b3JzOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBpZiAoY3JlYXRlQ3VzdG9tQ29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZywgY3JlYXRlQ3VzdG9tQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgICAgY29uc3QgYXJlQXJyYXlzRXF1YWwgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVBcnJheXNFcXVhbCk7XG4gICAgICAgIGNvbnN0IGFyZU1hcHNFcXVhbCA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZU1hcHNFcXVhbCk7XG4gICAgICAgIGNvbnN0IGFyZU9iamVjdHNFcXVhbCA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZU9iamVjdHNFcXVhbCk7XG4gICAgICAgIGNvbnN0IGFyZVNldHNFcXVhbCA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZVNldHNFcXVhbCk7XG4gICAgICAgIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZywge1xuICAgICAgICAgICAgYXJlQXJyYXlzRXF1YWwsXG4gICAgICAgICAgICBhcmVNYXBzRXF1YWwsXG4gICAgICAgICAgICBhcmVPYmplY3RzRXF1YWwsXG4gICAgICAgICAgICBhcmVTZXRzRXF1YWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xufVxuLyoqXG4gKiBEZWZhdWx0IGVxdWFsaXR5IGNvbXBhcmF0b3IgcGFzcy10aHJvdWdoLCB1c2VkIGFzIHRoZSBzdGFuZGFyZCBgaXNFcXVhbGAgY3JlYXRvciBmb3JcbiAqIHVzZSBpbnNpZGUgdGhlIGJ1aWx0IGNvbXBhcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVybmFsRXF1YWxpdHlDb21wYXJhdG9yKGNvbXBhcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIF9pbmRleE9yS2V5QSwgX2luZGV4T3JLZXlCLCBfcGFyZW50QSwgX3BhcmVudEIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlKGEsIGIsIHN0YXRlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGBpc0VxdWFsYCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBjb25zdW1pbmcgYXBwbGljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlzRXF1YWwoeyBjaXJjdWxhciwgY29tcGFyYXRvciwgY3JlYXRlU3RhdGUsIGVxdWFscywgc3RyaWN0IH0pIHtcbiAgICBpZiAoY3JlYXRlU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgICAgICAgICAgY29uc3QgeyBjYWNoZSA9IGNpcmN1bGFyID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZCwgbWV0YSB9ID0gY3JlYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgICBlcXVhbHMsXG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICBzdHJpY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICAgICAgICBlcXVhbHMsXG4gICAgICAgICAgICAgICAgbWV0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHN0cmljdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgY2FjaGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZXF1YWxzLFxuICAgICAgICBtZXRhOiB1bmRlZmluZWQsXG4gICAgICAgIHN0cmljdCxcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYiwgc3RhdGUpO1xuICAgIH07XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmNvbnN0IGRlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKCk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uLlxuICovXG5jb25zdCBzdHJpY3REZWVwRXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7IHN0cmljdDogdHJ1ZSB9KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxuICovXG5jb25zdCBjaXJjdWxhckRlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHsgY2lyY3VsYXI6IHRydWUgfSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uLlxuICovXG5jb25zdCBzdHJpY3RDaXJjdWxhckRlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBzdHJpY3Q6IHRydWUsXG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmNvbnN0IHNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6ICgpID0+IHNhbWVWYWx1ZVplcm9FcXVhbCxcbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZSBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvblxuICovXG5jb25zdCBzdHJpY3RTaGFsbG93RXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgc3RyaWN0OiB0cnVlLFxuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogKCkgPT4gc2FtZVZhbHVlWmVyb0VxdWFsLFxufSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqL1xuY29uc3QgY2lyY3VsYXJTaGFsbG93RXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiAoKSA9PiBzYW1lVmFsdWVaZXJvRXF1YWwsXG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb24uXG4gKi9cbmNvbnN0IHN0cmljdENpcmN1bGFyU2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogKCkgPT4gc2FtZVZhbHVlWmVyb0VxdWFsLFxuICAgIHN0cmljdDogdHJ1ZSxcbn0pO1xuLyoqXG4gKiBDcmVhdGUgYSBjdXN0b20gZXF1YWxpdHkgY29tcGFyaXNvbiBtZXRob2QuXG4gKlxuICogVGhpcyBjYW4gYmUgZG9uZSB0byBjcmVhdGUgdmVyeSB0YXJnZXRlZCBjb21wYXJpc29ucyBpbiBleHRyZW1lIGhvdC1wYXRoIHNjZW5hcmlvc1xuICogd2hlcmUgdGhlIHN0YW5kYXJkIG1ldGhvZHMgYXJlIG5vdCBwZXJmb3JtYW50IGVub3VnaCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZVxuICogc3VwcG9ydCBmb3IgbGVnYWN5IGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGV4cGVjdGVkIGZlYXR1cmVzIGxpa2VcbiAqIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBvdXQgb2YgdGhlIGJveC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXF1YWwob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaXJjdWxhciA9IGZhbHNlLCBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGNyZWF0ZUN1c3RvbUludGVybmFsQ29tcGFyYXRvciwgY3JlYXRlU3RhdGUsIHN0cmljdCA9IGZhbHNlLCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjb25maWcgPSBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3JDb25maWcob3B0aW9ucyk7XG4gICAgY29uc3QgY29tcGFyYXRvciA9IGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvcihjb25maWcpO1xuICAgIGNvbnN0IGVxdWFscyA9IGNyZWF0ZUN1c3RvbUludGVybmFsQ29tcGFyYXRvclxuICAgICAgICA/IGNyZWF0ZUN1c3RvbUludGVybmFsQ29tcGFyYXRvcihjb21wYXJhdG9yKVxuICAgICAgICA6IGNyZWF0ZUludGVybmFsRXF1YWxpdHlDb21wYXJhdG9yKGNvbXBhcmF0b3IpO1xuICAgIHJldHVybiBjcmVhdGVJc0VxdWFsKHsgY2lyY3VsYXIsIGNvbXBhcmF0b3IsIGNyZWF0ZVN0YXRlLCBlcXVhbHMsIHN0cmljdCB9KTtcbn1cblxuZXhwb3J0IHsgY2lyY3VsYXJEZWVwRXF1YWwsIGNpcmN1bGFyU2hhbGxvd0VxdWFsLCBjcmVhdGVDdXN0b21FcXVhbCwgZGVlcEVxdWFsLCBzYW1lVmFsdWVaZXJvRXF1YWwsIHNoYWxsb3dFcXVhbCwgc3RyaWN0Q2lyY3VsYXJEZWVwRXF1YWwsIHN0cmljdENpcmN1bGFyU2hhbGxvd0VxdWFsLCBzdHJpY3REZWVwRXF1YWwsIHN0cmljdFNoYWxsb3dFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3RvdHlwZSIsImNvbWJpbmVDb21wYXJhdG9ycyIsImNvbXBhcmF0b3JBIiwiY29tcGFyYXRvckIiLCJpc0VxdWFsIiwiYSIsImIiLCJzdGF0ZSIsImNyZWF0ZUlzQ2lyY3VsYXIiLCJhcmVJdGVtc0VxdWFsIiwiaXNDaXJjdWxhciIsImNhY2hlIiwiY2FjaGVkQSIsImdldCIsImNhY2hlZEIiLCJzZXQiLCJyZXN1bHQiLCJkZWxldGUiLCJnZXRTaG9ydFRhZyIsInZhbHVlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ1bmRlZmluZWQiLCJnZXRTdHJpY3RQcm9wZXJ0aWVzIiwib2JqZWN0IiwiY29uY2F0IiwiaGFzT3duIiwicHJvcGVydHkiLCJjYWxsIiwic2FtZVZhbHVlWmVyb0VxdWFsIiwiUFJFQUNUX1ZOT0RFIiwiUFJFQUNUX09XTkVSIiwiUkVBQ1RfT1dORVIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJrZXlzIiwiYXJlQXJyYXlCdWZmZXJzRXF1YWwiLCJieXRlTGVuZ3RoIiwiYXJlVHlwZWRBcnJheXNFcXVhbCIsIlVpbnQ4QXJyYXkiLCJhcmVBcnJheXNFcXVhbCIsImluZGV4IiwibGVuZ3RoIiwiZXF1YWxzIiwiYXJlRGF0YVZpZXdzRXF1YWwiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiYXJlRGF0ZXNFcXVhbCIsImdldFRpbWUiLCJhcmVFcnJvcnNFcXVhbCIsIm5hbWUiLCJtZXNzYWdlIiwiY2F1c2UiLCJzdGFjayIsImFyZUZ1bmN0aW9uc0VxdWFsIiwiYXJlTWFwc0VxdWFsIiwic2l6ZSIsIm1hdGNoZWRJbmRpY2VzIiwiQXJyYXkiLCJhSXRlcmFibGUiLCJlbnRyaWVzIiwiYVJlc3VsdCIsImJSZXN1bHQiLCJuZXh0IiwiZG9uZSIsImJJdGVyYWJsZSIsImhhc01hdGNoIiwibWF0Y2hJbmRleCIsImFFbnRyeSIsImJFbnRyeSIsImFyZU51bWJlcnNFcXVhbCIsImFyZU9iamVjdHNFcXVhbCIsInByb3BlcnRpZXMiLCJpc1Byb3BlcnR5RXF1YWwiLCJhcmVPYmplY3RzRXF1YWxTdHJpY3QiLCJkZXNjcmlwdG9yQSIsImRlc2NyaXB0b3JCIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbCIsInZhbHVlT2YiLCJhcmVSZWdFeHBzRXF1YWwiLCJzb3VyY2UiLCJmbGFncyIsImFyZVNldHNFcXVhbCIsInZhbHVlcyIsImFyZVVybHNFcXVhbCIsImhvc3RuYW1lIiwicGF0aG5hbWUiLCJwcm90b2NvbCIsInBvcnQiLCJoYXNoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIiQkdHlwZW9mIiwiQVJSQVlfQlVGRkVSX1RBRyIsIkFSR1VNRU5UU19UQUciLCJCT09MRUFOX1RBRyIsIkRBVEFfVklFV19UQUciLCJEQVRFX1RBRyIsIkVSUk9SX1RBRyIsIk1BUF9UQUciLCJOVU1CRVJfVEFHIiwiT0JKRUNUX1RBRyIsIlJFR19FWFBfVEFHIiwiU0VUX1RBRyIsIlNUUklOR19UQUciLCJUWVBFRF9BUlJBWV9UQUdTIiwiVVJMX1RBRyIsInRvU3RyaW5nIiwiY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yIiwidW5rbm93blRhZ0NvbXBhcmF0b3JzIiwiY29tcGFyYXRvciIsInR5cGUiLCJjb25zdHJ1Y3RvciIsImlzQXJyYXkiLCJEYXRlIiwiUmVnRXhwIiwiTWFwIiwiU2V0IiwidGFnIiwidGhlbiIsInVua25vd25UYWdDb21wYXJhdG9yIiwic2hvcnRUYWciLCJjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3JDb25maWciLCJjaXJjdWxhciIsImNyZWF0ZUN1c3RvbUNvbmZpZyIsInN0cmljdCIsImNvbmZpZyIsImFzc2lnbiIsImNyZWF0ZUludGVybmFsRXF1YWxpdHlDb21wYXJhdG9yIiwiY29tcGFyZSIsIl9pbmRleE9yS2V5QSIsIl9pbmRleE9yS2V5QiIsIl9wYXJlbnRBIiwiX3BhcmVudEIiLCJjcmVhdGVJc0VxdWFsIiwiY3JlYXRlU3RhdGUiLCJXZWFrTWFwIiwibWV0YSIsImRlZXBFcXVhbCIsImNyZWF0ZUN1c3RvbUVxdWFsIiwic3RyaWN0RGVlcEVxdWFsIiwiY2lyY3VsYXJEZWVwRXF1YWwiLCJzdHJpY3RDaXJjdWxhckRlZXBFcXVhbCIsInNoYWxsb3dFcXVhbCIsImNyZWF0ZUludGVybmFsQ29tcGFyYXRvciIsInN0cmljdFNoYWxsb3dFcXVhbCIsImNpcmN1bGFyU2hhbGxvd0VxdWFsIiwic3RyaWN0Q2lyY3VsYXJTaGFsbG93RXF1YWwiLCJvcHRpb25zIiwiY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/fast-equals/dist/es/index.mjs\n");

/***/ })

};
;