"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/big.js";
exports.ids = ["vendor-chunks/big.js"];
exports.modules = {

/***/ "(rsc)/../node_modules/big.js/big.mjs":
/*!**************************************!*\
  !*** ../node_modules/big.js/big.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Big: () => (/* binding */ Big),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *  big.js v6.2.2\r\n *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n *  Copyright (c) 2024 Michael Mclaughlin\r\n *  https://github.com/MikeMcl/big.js/LICENCE.md\r\n */ /************************************** EDITABLE DEFAULTS *****************************************/ // The default values below must be integers within the stated ranges.\n/*\r\n   * The maximum number of decimal places (DP) of the results of operations involving division:\r\n   * div and sqrt, and pow with negative exponents.\r\n   */ var DP = 20, /*\r\n   * The rounding mode (RM) used when rounding to the above decimal places.\r\n   *\r\n   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n   *  3  Away from zero.                                  (ROUND_UP)\r\n   */ RM = 1, // The maximum value of DP and Big.DP.\nMAX_DP = 1E6, // The maximum magnitude of the exponent argument to the pow method.\nMAX_POWER = 1E6, /*\r\n   * The negative exponent (NE) at and beneath which toString returns exponential notation.\r\n   * (JavaScript numbers: -7)\r\n   * -1000000 is the minimum recommended exponent value of a Big.\r\n   */ NE = -7, /*\r\n   * The positive exponent (PE) at and above which toString returns exponential notation.\r\n   * (JavaScript numbers: 21)\r\n   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.\r\n   */ PE = 21, /*\r\n   * When true, an error will be thrown if a primitive number is passed to the Big constructor,\r\n   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a\r\n   * primitive number without a loss of precision.\r\n   */ STRICT = false, /**************************************************************************************************/ // Error messages.\nNAME = \"[big.js] \", INVALID = NAME + \"Invalid \", INVALID_DP = INVALID + \"decimal places\", INVALID_RM = INVALID + \"rounding mode\", DIV_BY_ZERO = NAME + \"Division by zero\", // The shared prototype object.\nP = {}, UNDEFINED = void 0, NUMERIC = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i;\n/*\r\n * Create and return a Big constructor.\r\n */ function _Big_() {\n    /*\r\n   * The Big constructor and exported function.\r\n   * Create and return a new instance of a Big number object.\r\n   *\r\n   * n {number|string|Big} A numeric value.\r\n   */ function Big(n) {\n        var x = this;\n        // Enable constructor usage without new.\n        if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);\n        // Duplicate.\n        if (n instanceof Big) {\n            x.s = n.s;\n            x.e = n.e;\n            x.c = n.c.slice();\n        } else {\n            if (typeof n !== \"string\") {\n                if (Big.strict === true && typeof n !== \"bigint\") {\n                    throw TypeError(INVALID + \"value\");\n                }\n                // Minus zero?\n                n = n === 0 && 1 / n < 0 ? \"-0\" : String(n);\n            }\n            parse(x, n);\n        }\n        // Retain a reference to this Big constructor.\n        // Shadow Big.prototype.constructor which points to Object.\n        x.constructor = Big;\n    }\n    Big.prototype = P;\n    Big.DP = DP;\n    Big.RM = RM;\n    Big.NE = NE;\n    Big.PE = PE;\n    Big.strict = STRICT;\n    Big.roundDown = 0;\n    Big.roundHalfUp = 1;\n    Big.roundHalfEven = 2;\n    Big.roundUp = 3;\n    return Big;\n}\n/*\r\n * Parse the number or string value passed to a Big constructor.\r\n *\r\n * x {Big} A Big number instance.\r\n * n {number|string} A numeric value.\r\n */ function parse(x, n) {\n    var e, i, nl;\n    if (!NUMERIC.test(n)) {\n        throw Error(INVALID + \"number\");\n    }\n    // Determine sign.\n    x.s = n.charAt(0) == \"-\" ? (n = n.slice(1), -1) : 1;\n    // Decimal point?\n    if ((e = n.indexOf(\".\")) > -1) n = n.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = n.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +n.slice(i + 1);\n        n = n.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = n.length;\n    }\n    nl = n.length;\n    // Determine leading zeros.\n    for(i = 0; i < nl && n.charAt(i) == \"0\";)++i;\n    if (i == nl) {\n        // Zero.\n        x.c = [\n            x.e = 0\n        ];\n    } else {\n        // Determine trailing zeros.\n        for(; nl > 0 && n.charAt(--nl) == \"0\";);\n        x.e = e - i - 1;\n        x.c = [];\n        // Convert string to array of digits without leading/trailing zeros.\n        for(e = 0; i <= nl;)x.c[e++] = +n.charAt(i++);\n    }\n    return x;\n}\n/*\r\n * Round Big x to a maximum of sd significant digits using rounding mode rm.\r\n *\r\n * x {Big} The Big to round.\r\n * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.\r\n * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n * [more] {boolean} Whether the result of division was truncated.\r\n */ function round(x, sd, rm, more) {\n    var xc = x.c;\n    if (rm === UNDEFINED) rm = x.constructor.RM;\n    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {\n        throw Error(INVALID_RM);\n    }\n    if (sd < 1) {\n        more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));\n        xc.length = 1;\n        if (more) {\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n            x.e = x.e - sd + 1;\n            xc[0] = 1;\n        } else {\n            // Zero.\n            xc[0] = x.e = 0;\n        }\n    } else if (sd < xc.length) {\n        // xc[sd] is the digit after the digit that may be rounded up.\n        more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);\n        // Remove any digits after the required precision.\n        xc.length = sd;\n        // Round up?\n        if (more) {\n            // Rounding up may mean the previous digit has to be rounded up.\n            for(; ++xc[--sd] > 9;){\n                xc[sd] = 0;\n                if (sd === 0) {\n                    ++x.e;\n                    xc.unshift(1);\n                    break;\n                }\n            }\n        }\n        // Remove trailing zeros.\n        for(sd = xc.length; !xc[--sd];)xc.pop();\n    }\n    return x;\n}\n/*\r\n * Return a string representing the value of Big x in normal or exponential notation.\r\n * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.\r\n */ function stringify(x, doExponential, isNonzero) {\n    var e = x.e, s = x.c.join(\"\"), n = s.length;\n    // Exponential notation?\n    if (doExponential) {\n        s = s.charAt(0) + (n > 1 ? \".\" + s.slice(1) : \"\") + (e < 0 ? \"e\" : \"e+\") + e;\n    // Normal notation.\n    } else if (e < 0) {\n        for(; ++e;)s = \"0\" + s;\n        s = \"0.\" + s;\n    } else if (e > 0) {\n        if (++e > n) {\n            for(e -= n; e--;)s += \"0\";\n        } else if (e < n) {\n            s = s.slice(0, e) + \".\" + s.slice(e);\n        }\n    } else if (n > 1) {\n        s = s.charAt(0) + \".\" + s.slice(1);\n    }\n    return x.s < 0 && isNonzero ? \"-\" + s : s;\n}\n// Prototype/instance methods\n/*\r\n * Return a new Big whose value is the absolute value of this Big.\r\n */ P.abs = function() {\n    var x = new this.constructor(this);\n    x.s = 1;\n    return x;\n};\n/*\r\n * Return 1 if the value of this Big is greater than the value of Big y,\r\n *       -1 if the value of this Big is less than the value of Big y, or\r\n *        0 if they have the same value.\r\n */ P.cmp = function(y) {\n    var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;\n    // Signs differ?\n    if (i != j) return i;\n    isneg = i < 0;\n    // Compare exponents.\n    if (k != l) return k > l ^ isneg ? 1 : -1;\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n    // Compare digit by digit.\n    for(i = -1; ++i < j;){\n        if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;\n    }\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ isneg ? 1 : -1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,\r\n * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.div = function(y) {\n    var x = this, Big = x.constructor, a = x.c, b = (y = new Big(y)).c, k = x.s == y.s ? 1 : -1, dp = Big.DP;\n    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n    }\n    // Divisor is zero?\n    if (!b[0]) {\n        throw Error(DIV_BY_ZERO);\n    }\n    // Dividend is 0? Return +-0.\n    if (!a[0]) {\n        y.s = k;\n        y.c = [\n            y.e = 0\n        ];\n        return y;\n    }\n    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1; // precision of the result\n    q.s = k;\n    k = p < 0 ? 0 : p;\n    // Create version of divisor with leading zero.\n    bz.unshift(0);\n    // Add zeros to make remainder as long as divisor.\n    for(; rl++ < bl;)r.push(0);\n    do {\n        // n is how many times the divisor goes into current remainder.\n        for(n = 0; n < 10; n++){\n            // Compare divisor and remainder.\n            if (bl != (rl = r.length)) {\n                cmp = bl > rl ? 1 : -1;\n            } else {\n                for(ri = -1, cmp = 0; ++ri < bl;){\n                    if (b[ri] != r[ri]) {\n                        cmp = b[ri] > r[ri] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            // If divisor < remainder, subtract divisor from remainder.\n            if (cmp < 0) {\n                // Remainder can't be more than 1 digit longer than divisor.\n                // Equalise lengths using divisor with extra leading zero?\n                for(bt = rl == bl ? b : bz; rl;){\n                    if (r[--rl] < bt[rl]) {\n                        ri = rl;\n                        for(; ri && !r[--ri];)r[ri] = 9;\n                        --r[ri];\n                        r[rl] += 10;\n                    }\n                    r[rl] -= bt[rl];\n                }\n                for(; !r[0];)r.shift();\n            } else {\n                break;\n            }\n        }\n        // Add the digit n to the result array.\n        qc[qi++] = cmp ? n : ++n;\n        // Update the remainder.\n        if (r[0] && cmp) r[rl] = a[ai] || 0;\n        else r = [\n            a[ai]\n        ];\n    }while ((ai++ < al || r[0] !== UNDEFINED) && k--);\n    // Leading zero? Do not remove if result is simply zero (qi == 1).\n    if (!qc[0] && qi != 1) {\n        // There can't be more than one zero.\n        qc.shift();\n        q.e--;\n        p--;\n    }\n    // Round?\n    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);\n    return q;\n};\n/*\r\n * Return true if the value of this Big is equal to the value of Big y, otherwise return false.\r\n */ P.eq = function(y) {\n    return this.cmp(y) === 0;\n};\n/*\r\n * Return true if the value of this Big is greater than the value of Big y, otherwise return\r\n * false.\r\n */ P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.gte = function(y) {\n    return this.cmp(y) > -1;\n};\n/*\r\n * Return true if the value of this Big is less than the value of Big y, otherwise return false.\r\n */ P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Big is less than or equal to the value of Big y, otherwise\r\n * return false.\r\n */ P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return a new Big whose value is the value of this Big minus the value of Big y.\r\n */ P.minus = P.sub = function(y) {\n    var i, j, t, xlty, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    // Signs differ?\n    if (a != b) {\n        y.s = -b;\n        return x.plus(y);\n    }\n    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        if (yc[0]) {\n            y.s = -b;\n        } else if (xc[0]) {\n            y = new Big(x);\n        } else {\n            y.s = 1;\n        }\n        return y;\n    }\n    // Determine which is the bigger number. Prepend zeros to equalise exponents.\n    if (a = xe - ye) {\n        if (xlty = a < 0) {\n            a = -a;\n            t = xc;\n        } else {\n            ye = xe;\n            t = yc;\n        }\n        t.reverse();\n        for(b = a; b--;)t.push(0);\n        t.reverse();\n    } else {\n        // Exponents equal. Check digit by digit.\n        j = ((xlty = xc.length < yc.length) ? xc : yc).length;\n        for(a = b = 0; b < j; b++){\n            if (xc[b] != yc[b]) {\n                xlty = xc[b] < yc[b];\n                break;\n            }\n        }\n    }\n    // x < y? Point xc to the array of the bigger number.\n    if (xlty) {\n        t = xc;\n        xc = yc;\n        yc = t;\n        y.s = -y.s;\n    }\n    /*\r\n   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only\r\n   * needs to start at yc.length.\r\n   */ if ((b = (j = yc.length) - (i = xc.length)) > 0) for(; b--;)xc[i++] = 0;\n    // Subtract yc from xc.\n    for(b = i; j > a;){\n        if (xc[--j] < yc[j]) {\n            for(i = j; i && !xc[--i];)xc[i] = 9;\n            --xc[i];\n            xc[j] += 10;\n        }\n        xc[j] -= yc[j];\n    }\n    // Remove trailing zeros.\n    for(; xc[--b] === 0;)xc.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xc[0] === 0;){\n        xc.shift();\n        --ye;\n    }\n    if (!xc[0]) {\n        // n - n = +0\n        y.s = 1;\n        // Result must be zero.\n        xc = [\n            ye = 0\n        ];\n    }\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big modulo the value of Big y.\r\n */ P.mod = function(y) {\n    var ygtx, x = this, Big = x.constructor, a = x.s, b = (y = new Big(y)).s;\n    if (!y.c[0]) {\n        throw Error(DIV_BY_ZERO);\n    }\n    x.s = y.s = 1;\n    ygtx = y.cmp(x) == 1;\n    x.s = a;\n    y.s = b;\n    if (ygtx) return new Big(x);\n    a = Big.DP;\n    b = Big.RM;\n    Big.DP = Big.RM = 0;\n    x = x.div(y);\n    Big.DP = a;\n    Big.RM = b;\n    return this.minus(x.times(y));\n};\n/*\r\n * Return a new Big whose value is the value of this Big negated.\r\n */ P.neg = function() {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return x;\n};\n/*\r\n * Return a new Big whose value is the value of this Big plus the value of Big y.\r\n */ P.plus = P.add = function(y) {\n    var e, k, t, x = this, Big = x.constructor;\n    y = new Big(y);\n    // Signs differ?\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n    }\n    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;\n    // Either zero?\n    if (!xc[0] || !yc[0]) {\n        if (!yc[0]) {\n            if (xc[0]) {\n                y = new Big(x);\n            } else {\n                y.s = x.s;\n            }\n        }\n        return y;\n    }\n    xc = xc.slice();\n    // Prepend zeros to equalise exponents.\n    // Note: reverse faster than unshifts.\n    if (e = xe - ye) {\n        if (e > 0) {\n            ye = xe;\n            t = yc;\n        } else {\n            e = -e;\n            t = xc;\n        }\n        t.reverse();\n        for(; e--;)t.push(0);\n        t.reverse();\n    }\n    // Point xc to the longer array.\n    if (xc.length - yc.length < 0) {\n        t = yc;\n        yc = xc;\n        xc = t;\n    }\n    e = yc.length;\n    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.\n    for(k = 0; e; xc[e] %= 10)k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    if (k) {\n        xc.unshift(k);\n        ++ye;\n    }\n    // Remove trailing zeros.\n    for(e = xc.length; xc[--e] === 0;)xc.pop();\n    y.c = xc;\n    y.e = ye;\n    return y;\n};\n/*\r\n * Return a Big whose value is the value of this Big raised to the power n.\r\n * If n is negative, round to a maximum of Big.DP decimal places using rounding\r\n * mode Big.RM.\r\n *\r\n * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n */ P.pow = function(n) {\n    var x = this, one = new x.constructor(\"1\"), y = one, isneg = n < 0;\n    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\n        throw Error(INVALID + \"exponent\");\n    }\n    if (isneg) n = -n;\n    for(;;){\n        if (n & 1) y = y.times(x);\n        n >>= 1;\n        if (!n) break;\n        x = x.times(x);\n    }\n    return isneg ? one.div(y) : y;\n};\n/*\r\n * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd\r\n * significant digits using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.prec = function(sd, rm) {\n    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n        throw Error(INVALID + \"precision\");\n    }\n    return round(new this.constructor(this), sd, rm);\n};\n/*\r\n * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places\r\n * using rounding mode rm, or Big.RM if rm is not specified.\r\n * If dp is negative, round to an integer which is a multiple of 10**-dp.\r\n * If dp is not specified, round to 0 decimal places.\r\n *\r\n * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.round = function(dp, rm) {\n    if (dp === UNDEFINED) dp = 0;\n    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {\n        throw Error(INVALID_DP);\n    }\n    return round(new this.constructor(this), dp + this.e + 1, rm);\n};\n/*\r\n * Return a new Big whose value is the square root of the value of this Big, rounded, if\r\n * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.\r\n */ P.sqrt = function() {\n    var r, c, t, x = this, Big = x.constructor, s = x.s, e = x.e, half = new Big(\"0.5\");\n    // Zero?\n    if (!x.c[0]) return new Big(x);\n    // Negative?\n    if (s < 0) {\n        throw Error(NAME + \"No square root\");\n    }\n    // Estimate.\n    s = Math.sqrt(+stringify(x, true, true));\n    // Math.sqrt underflow/overflow?\n    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.\n    if (s === 0 || s === 1 / 0) {\n        c = x.c.join(\"\");\n        if (!(c.length + e & 1)) c += \"0\";\n        s = Math.sqrt(c);\n        e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\n        r = new Big((s == 1 / 0 ? \"5e\" : (s = s.toExponential()).slice(0, s.indexOf(\"e\") + 1)) + e);\n    } else {\n        r = new Big(s + \"\");\n    }\n    e = r.e + (Big.DP += 4);\n    // Newton-Raphson iteration.\n    do {\n        t = r;\n        r = half.times(t.plus(x.div(t)));\n    }while (t.c.slice(0, e).join(\"\") !== r.c.slice(0, e).join(\"\"));\n    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);\n};\n/*\r\n * Return a new Big whose value is the value of this Big times the value of Big y.\r\n */ P.times = P.mul = function(y) {\n    var c, x = this, Big = x.constructor, xc = x.c, yc = (y = new Big(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;\n    // Determine sign of result.\n    y.s = x.s == y.s ? 1 : -1;\n    // Return signed 0 if either 0.\n    if (!xc[0] || !yc[0]) {\n        y.c = [\n            y.e = 0\n        ];\n        return y;\n    }\n    // Initialise exponent of result as x.e + y.e.\n    y.e = i + j;\n    // If array xc has fewer digits than yc, swap xc and yc, and lengths.\n    if (a < b) {\n        c = xc;\n        xc = yc;\n        yc = c;\n        j = a;\n        a = b;\n        b = j;\n    }\n    // Initialise coefficient array of result with zeros.\n    for(c = new Array(j = a + b); j--;)c[j] = 0;\n    // Multiply.\n    // i is initially xc.length.\n    for(i = b; i--;){\n        b = 0;\n        // a is yc.length.\n        for(j = a + i; j > i;){\n            // Current sum of products at this digit position, plus carry.\n            b = c[j] + yc[i] * xc[j - i - 1] + b;\n            c[j--] = b % 10;\n            // carry\n            b = b / 10 | 0;\n        }\n        c[j] = b;\n    }\n    // Increment result exponent if there is a final carry, otherwise remove leading zero.\n    if (b) ++y.e;\n    else c.shift();\n    // Remove trailing zeros.\n    for(i = c.length; !c[--i];)c.pop();\n    y.c = c;\n    return y;\n};\n/*\r\n * Return a string representing the value of this Big in exponential notation rounded to dp fixed\r\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.toExponential = function(dp, rm) {\n    var x = this, n = x.c[0];\n    if (dp !== UNDEFINED) {\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n            throw Error(INVALID_DP);\n        }\n        x = round(new x.constructor(x), ++dp, rm);\n        for(; x.c.length < dp;)x.c.push(0);\n    }\n    return stringify(x, true, !!n);\n};\n/*\r\n * Return a string representing the value of this Big in normal notation rounded to dp fixed\r\n * decimal places using rounding mode rm, or Big.RM if rm is not specified.\r\n *\r\n * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n */ P.toFixed = function(dp, rm) {\n    var x = this, n = x.c[0];\n    if (dp !== UNDEFINED) {\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\n            throw Error(INVALID_DP);\n        }\n        x = round(new x.constructor(x), dp + x.e + 1, rm);\n        // x.e may have changed if the value is rounded up.\n        for(dp = dp + x.e + 1; x.c.length < dp;)x.c.push(0);\n    }\n    return stringify(x, false, !!n);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Omit the sign for negative zero.\r\n */ P[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toJSON = P.toString = function() {\n    var x = this, Big = x.constructor;\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);\n};\n/*\r\n * Return the value of this Big as a primitve number.\r\n */ P.toNumber = function() {\n    var n = +stringify(this, true, true);\n    if (this.constructor.strict === true && !this.eq(n.toString())) {\n        throw Error(NAME + \"Imprecise conversion\");\n    }\n    return n;\n};\n/*\r\n * Return a string representing the value of this Big rounded to sd significant digits using\r\n * rounding mode rm, or Big.RM if rm is not specified.\r\n * Use exponential notation if sd is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.\r\n * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).\r\n */ P.toPrecision = function(sd, rm) {\n    var x = this, Big = x.constructor, n = x.c[0];\n    if (sd !== UNDEFINED) {\n        if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\n            throw Error(INVALID + \"precision\");\n        }\n        x = round(new Big(x), sd, rm);\n        for(; x.c.length < sd;)x.c.push(0);\n    }\n    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);\n};\n/*\r\n * Return a string representing the value of this Big.\r\n * Return exponential notation if this Big has a positive exponent equal to or greater than\r\n * Big.PE, or a negative exponent equal to or less than Big.NE.\r\n * Include the sign for negative zero.\r\n */ P.valueOf = function() {\n    var x = this, Big = x.constructor;\n    if (Big.strict === true) {\n        throw Error(NAME + \"valueOf disallowed\");\n    }\n    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);\n};\n// Export\nvar Big = _Big_();\n/// <reference types=\"https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts\" />\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2JpZy5qcy9iaWcubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FHRCxrR0FBa0csR0FHaEcsc0VBQXNFO0FBRXRFOzs7R0FHQyxHQUNILElBQUlBLEtBQUssSUFFUDs7Ozs7OztHQU9DLEdBQ0RDLEtBQUssR0FFTCxzQ0FBc0M7QUFDdENDLFNBQVMsS0FFVCxvRUFBb0U7QUFDcEVDLFlBQVksS0FFWjs7OztHQUlDLEdBQ0RDLEtBQUssQ0FBQyxHQUVOOzs7O0dBSUMsR0FDREMsS0FBSyxJQUVMOzs7O0dBSUMsR0FDREMsU0FBUyxPQUdYLGtHQUFrRyxHQUdoRyxrQkFBa0I7QUFDbEJDLE9BQU8sYUFDUEMsVUFBVUQsT0FBTyxZQUNqQkUsYUFBYUQsVUFBVSxrQkFDdkJFLGFBQWFGLFVBQVUsaUJBQ3ZCRyxjQUFjSixPQUFPLG9CQUVyQiwrQkFBK0I7QUFDL0JLLElBQUksQ0FBQyxHQUNMQyxZQUFZLEtBQUssR0FDakJDLFVBQVU7QUFHWjs7Q0FFQyxHQUNELFNBQVNDO0lBRVA7Ozs7O0dBS0MsR0FDRCxTQUFTQyxJQUFJQyxDQUFDO1FBQ1osSUFBSUMsSUFBSSxJQUFJO1FBRVosd0NBQXdDO1FBQ3hDLElBQUksQ0FBRUEsQ0FBQUEsYUFBYUYsR0FBRSxHQUFJLE9BQU9DLE1BQU1KLFlBQVlFLFVBQVUsSUFBSUMsSUFBSUM7UUFFcEUsYUFBYTtRQUNiLElBQUlBLGFBQWFELEtBQUs7WUFDcEJFLEVBQUVDLENBQUMsR0FBR0YsRUFBRUUsQ0FBQztZQUNURCxFQUFFRSxDQUFDLEdBQUdILEVBQUVHLENBQUM7WUFDVEYsRUFBRUcsQ0FBQyxHQUFHSixFQUFFSSxDQUFDLENBQUNDLEtBQUs7UUFDakIsT0FBTztZQUNMLElBQUksT0FBT0wsTUFBTSxVQUFVO2dCQUN6QixJQUFJRCxJQUFJTyxNQUFNLEtBQUssUUFBUSxPQUFPTixNQUFNLFVBQVU7b0JBQ2hELE1BQU1PLFVBQVVoQixVQUFVO2dCQUM1QjtnQkFF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R0FDREwsRUFBRXNHLE9BQU8sR0FBRztJQUNWLElBQUloRyxJQUFJLElBQUksRUFDVkYsTUFBTUUsRUFBRVMsV0FBVztJQUNyQixJQUFJWCxJQUFJTyxNQUFNLEtBQUssTUFBTTtRQUN2QixNQUFNYSxNQUFNN0IsT0FBTztJQUNyQjtJQUNBLE9BQU8yQyxVQUFVaEMsR0FBR0EsRUFBRUUsQ0FBQyxJQUFJSixJQUFJWixFQUFFLElBQUljLEVBQUVFLENBQUMsSUFBSUosSUFBSVgsRUFBRSxFQUFFO0FBQ3REO0FBR0EsU0FBUztBQUdGLElBQUlXLE1BQU1ELFFBQVE7QUFFekIsMEhBQTBIO0FBQzFILGlFQUFlQyxHQUFHQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbG9hbi1yZWZpbmFuY2Utc2ltdWxhdG9yLy4uL25vZGVfbW9kdWxlcy9iaWcuanMvYmlnLm1qcz82MWM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqICBiaWcuanMgdjYuMi4yXHJcbiAqICBBIHNtYWxsLCBmYXN0LCBlYXN5LXRvLXVzZSBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGRlY2ltYWwgYXJpdGhtZXRpYy5cclxuICogIENvcHlyaWdodCAoYykgMjAyNCBNaWNoYWVsIE1jbGF1Z2hsaW5cclxuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9MSUNFTkNFLm1kXHJcbiAqL1xyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRElUQUJMRSBERUZBVUxUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgc3RhdGVkIHJhbmdlcy5cclxuXHJcbiAgLypcclxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgKERQKSBvZiB0aGUgcmVzdWx0cyBvZiBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbjpcclxuICAgKiBkaXYgYW5kIHNxcnQsIGFuZCBwb3cgd2l0aCBuZWdhdGl2ZSBleHBvbmVudHMuXHJcbiAgICovXHJcbnZhciBEUCA9IDIwLCAgICAgICAgICAvLyAwIHRvIE1BWF9EUFxyXG5cclxuICAvKlxyXG4gICAqIFRoZSByb3VuZGluZyBtb2RlIChSTSkgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcy5cclxuICAgKlxyXG4gICAqICAwICBUb3dhcmRzIHplcm8gKGkuZS4gdHJ1bmNhdGUsIG5vIHJvdW5kaW5nKS4gICAgICAgKFJPVU5EX0RPV04pXHJcbiAgICogIDEgIFRvIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgcm91bmQgdXAuICAoUk9VTkRfSEFMRl9VUClcclxuICAgKiAgMiAgVG8gbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0byBldmVuLiAgIChST1VORF9IQUxGX0VWRU4pXHJcbiAgICogIDMgIEF3YXkgZnJvbSB6ZXJvLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoUk9VTkRfVVApXHJcbiAgICovXHJcbiAgUk0gPSAxLCAgICAgICAgICAgICAvLyAwLCAxLCAyIG9yIDNcclxuXHJcbiAgLy8gVGhlIG1heGltdW0gdmFsdWUgb2YgRFAgYW5kIEJpZy5EUC5cclxuICBNQVhfRFAgPSAxRTYsICAgICAgIC8vIDAgdG8gMTAwMDAwMFxyXG5cclxuICAvLyBUaGUgbWF4aW11bSBtYWduaXR1ZGUgb2YgdGhlIGV4cG9uZW50IGFyZ3VtZW50IHRvIHRoZSBwb3cgbWV0aG9kLlxyXG4gIE1BWF9QT1dFUiA9IDFFNiwgICAgLy8gMSB0byAxMDAwMDAwXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIG5lZ2F0aXZlIGV4cG9uZW50IChORSkgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKiAoSmF2YVNjcmlwdCBudW1iZXJzOiAtNylcclxuICAgKiAtMTAwMDAwMCBpcyB0aGUgbWluaW11bSByZWNvbW1lbmRlZCBleHBvbmVudCB2YWx1ZSBvZiBhIEJpZy5cclxuICAgKi9cclxuICBORSA9IC03LCAgICAgICAgICAgIC8vIDAgdG8gLTEwMDAwMDBcclxuXHJcbiAgLypcclxuICAgKiBUaGUgcG9zaXRpdmUgZXhwb25lbnQgKFBFKSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKiAoSmF2YVNjcmlwdCBudW1iZXJzOiAyMSlcclxuICAgKiAxMDAwMDAwIGlzIHRoZSBtYXhpbXVtIHJlY29tbWVuZGVkIGV4cG9uZW50IHZhbHVlIG9mIGEgQmlnLCBidXQgdGhpcyBsaW1pdCBpcyBub3QgZW5mb3JjZWQuXHJcbiAgICovXHJcbiAgUEUgPSAyMSwgICAgICAgICAgICAvLyAwIHRvIDEwMDAwMDBcclxuXHJcbiAgLypcclxuICAgKiBXaGVuIHRydWUsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIGEgcHJpbWl0aXZlIG51bWJlciBpcyBwYXNzZWQgdG8gdGhlIEJpZyBjb25zdHJ1Y3RvcixcclxuICAgKiBvciBpZiB2YWx1ZU9mIGlzIGNhbGxlZCwgb3IgaWYgdG9OdW1iZXIgaXMgY2FsbGVkIG9uIGEgQmlnIHdoaWNoIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYVxyXG4gICAqIHByaW1pdGl2ZSBudW1iZXIgd2l0aG91dCBhIGxvc3Mgb2YgcHJlY2lzaW9uLlxyXG4gICAqL1xyXG4gIFNUUklDVCA9IGZhbHNlLCAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gIC8vIEVycm9yIG1lc3NhZ2VzLlxyXG4gIE5BTUUgPSAnW2JpZy5qc10gJyxcclxuICBJTlZBTElEID0gTkFNRSArICdJbnZhbGlkICcsXHJcbiAgSU5WQUxJRF9EUCA9IElOVkFMSUQgKyAnZGVjaW1hbCBwbGFjZXMnLFxyXG4gIElOVkFMSURfUk0gPSBJTlZBTElEICsgJ3JvdW5kaW5nIG1vZGUnLFxyXG4gIERJVl9CWV9aRVJPID0gTkFNRSArICdEaXZpc2lvbiBieSB6ZXJvJyxcclxuXHJcbiAgLy8gVGhlIHNoYXJlZCBwcm90b3R5cGUgb2JqZWN0LlxyXG4gIFAgPSB7fSxcclxuICBVTkRFRklORUQgPSB2b2lkIDAsXHJcbiAgTlVNRVJJQyA9IC9eLT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pO1xyXG5cclxuXHJcbi8qXHJcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuZnVuY3Rpb24gX0JpZ18oKSB7XHJcblxyXG4gIC8qXHJcbiAgICogVGhlIEJpZyBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWcgbnVtYmVyIG9iamVjdC5cclxuICAgKlxyXG4gICAqIG4ge251bWJlcnxzdHJpbmd8QmlnfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gQmlnKG4pIHtcclxuICAgIHZhciB4ID0gdGhpcztcclxuXHJcbiAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgdXNhZ2Ugd2l0aG91dCBuZXcuXHJcbiAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnKSkgcmV0dXJuIG4gPT09IFVOREVGSU5FRCA/IF9CaWdfKCkgOiBuZXcgQmlnKG4pO1xyXG5cclxuICAgIC8vIER1cGxpY2F0ZS5cclxuICAgIGlmIChuIGluc3RhbmNlb2YgQmlnKSB7XHJcbiAgICAgIHgucyA9IG4ucztcclxuICAgICAgeC5lID0gbi5lO1xyXG4gICAgICB4LmMgPSBuLmMuc2xpY2UoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0eXBlb2YgbiAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICBpZiAoQmlnLnN0cmljdCA9PT0gdHJ1ZSAmJiB0eXBlb2YgbiAhPT0gJ2JpZ2ludCcpIHtcclxuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihJTlZBTElEICsgJ3ZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNaW51cyB6ZXJvP1xyXG4gICAgICAgIG4gPSBuID09PSAwICYmIDEgLyBuIDwgMCA/ICctMCcgOiBTdHJpbmcobik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHBhcnNlKHgsIG4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGlzIEJpZyBjb25zdHJ1Y3Rvci5cclxuICAgIC8vIFNoYWRvdyBCaWcucHJvdG90eXBlLmNvbnN0cnVjdG9yIHdoaWNoIHBvaW50cyB0byBPYmplY3QuXHJcbiAgICB4LmNvbnN0cnVjdG9yID0gQmlnO1xyXG4gIH1cclxuXHJcbiAgQmlnLnByb3RvdHlwZSA9IFA7XHJcbiAgQmlnLkRQID0gRFA7XHJcbiAgQmlnLlJNID0gUk07XHJcbiAgQmlnLk5FID0gTkU7XHJcbiAgQmlnLlBFID0gUEU7XHJcbiAgQmlnLnN0cmljdCA9IFNUUklDVDtcclxuICBCaWcucm91bmREb3duID0gMDtcclxuICBCaWcucm91bmRIYWxmVXAgPSAxO1xyXG4gIEJpZy5yb3VuZEhhbGZFdmVuID0gMjtcclxuICBCaWcucm91bmRVcCA9IDM7XHJcblxyXG4gIHJldHVybiBCaWc7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBQYXJzZSB0aGUgbnVtYmVyIG9yIHN0cmluZyB2YWx1ZSBwYXNzZWQgdG8gYSBCaWcgY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIHgge0JpZ30gQSBCaWcgbnVtYmVyIGluc3RhbmNlLlxyXG4gKiBuIHtudW1iZXJ8c3RyaW5nfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZSh4LCBuKSB7XHJcbiAgdmFyIGUsIGksIG5sO1xyXG5cclxuICBpZiAoIU5VTUVSSUMudGVzdChuKSkge1xyXG4gICAgdGhyb3cgRXJyb3IoSU5WQUxJRCArICdudW1iZXInKTtcclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZSBzaWduLlxyXG4gIHgucyA9IG4uY2hhckF0KDApID09ICctJyA/IChuID0gbi5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgLy8gRGVjaW1hbCBwb2ludD9cclxuICBpZiAoKGUgPSBuLmluZGV4T2YoJy4nKSkgPiAtMSkgbiA9IG4ucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICBpZiAoKGkgPSBuLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgIGUgKz0gK24uc2xpY2UoaSArIDEpO1xyXG4gICAgbiA9IG4uc3Vic3RyaW5nKDAsIGkpO1xyXG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAvLyBJbnRlZ2VyLlxyXG4gICAgZSA9IG4ubGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgbmwgPSBuLmxlbmd0aDtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgZm9yIChpID0gMDsgaSA8IG5sICYmIG4uY2hhckF0KGkpID09ICcwJzspICsraTtcclxuXHJcbiAgaWYgKGkgPT0gbmwpIHtcclxuXHJcbiAgICAvLyBaZXJvLlxyXG4gICAgeC5jID0gW3guZSA9IDBdO1xyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yICg7IG5sID4gMCAmJiBuLmNoYXJBdCgtLW5sKSA9PSAnMCc7KTtcclxuICAgIHguZSA9IGUgLSBpIC0gMTtcclxuICAgIHguYyA9IFtdO1xyXG5cclxuICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5IG9mIGRpZ2l0cyB3aXRob3V0IGxlYWRpbmcvdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGUgPSAwOyBpIDw9IG5sOykgeC5jW2UrK10gPSArbi5jaGFyQXQoaSsrKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4O1xyXG59XHJcblxyXG5cclxuLypcclxuICogUm91bmQgQmlnIHggdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLlxyXG4gKlxyXG4gKiB4IHtCaWd9IFRoZSBCaWcgdG8gcm91bmQuXHJcbiAqIHNkIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlOiAwIChkb3duKSwgMSAoaGFsZi11cCksIDIgKGhhbGYtZXZlbikgb3IgMyAodXApLlxyXG4gKiBbbW9yZV0ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiB3YXMgdHJ1bmNhdGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCBtb3JlKSB7XHJcbiAgdmFyIHhjID0geC5jO1xyXG5cclxuICBpZiAocm0gPT09IFVOREVGSU5FRCkgcm0gPSB4LmNvbnN0cnVjdG9yLlJNO1xyXG4gIGlmIChybSAhPT0gMCAmJiBybSAhPT0gMSAmJiBybSAhPT0gMiAmJiBybSAhPT0gMykge1xyXG4gICAgdGhyb3cgRXJyb3IoSU5WQUxJRF9STSk7XHJcbiAgfVxyXG5cclxuICBpZiAoc2QgPCAxKSB7XHJcbiAgICBtb3JlID1cclxuICAgICAgcm0gPT09IDMgJiYgKG1vcmUgfHwgISF4Y1swXSkgfHwgc2QgPT09IDAgJiYgKFxyXG4gICAgICBybSA9PT0gMSAmJiB4Y1swXSA+PSA1IHx8XHJcbiAgICAgIHJtID09PSAyICYmICh4Y1swXSA+IDUgfHwgeGNbMF0gPT09IDUgJiYgKG1vcmUgfHwgeGNbMV0gIT09IFVOREVGSU5FRCkpXHJcbiAgICApO1xyXG5cclxuICAgIHhjLmxlbmd0aCA9IDE7XHJcblxyXG4gICAgaWYgKG1vcmUpIHtcclxuXHJcbiAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgIHguZSA9IHguZSAtIHNkICsgMTtcclxuICAgICAgeGNbMF0gPSAxO1xyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIFplcm8uXHJcbiAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKHNkIDwgeGMubGVuZ3RoKSB7XHJcblxyXG4gICAgLy8geGNbc2RdIGlzIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgIG1vcmUgPVxyXG4gICAgICBybSA9PT0gMSAmJiB4Y1tzZF0gPj0gNSB8fFxyXG4gICAgICBybSA9PT0gMiAmJiAoeGNbc2RdID4gNSB8fCB4Y1tzZF0gPT09IDUgJiZcclxuICAgICAgICAobW9yZSB8fCB4Y1tzZCArIDFdICE9PSBVTkRFRklORUQgfHwgeGNbc2QgLSAxXSAmIDEpKSB8fFxyXG4gICAgICBybSA9PT0gMyAmJiAobW9yZSB8fCAhIXhjWzBdKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgYW55IGRpZ2l0cyBhZnRlciB0aGUgcmVxdWlyZWQgcHJlY2lzaW9uLlxyXG4gICAgeGMubGVuZ3RoID0gc2Q7XHJcblxyXG4gICAgLy8gUm91bmQgdXA/XHJcbiAgICBpZiAobW9yZSkge1xyXG5cclxuICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwLlxyXG4gICAgICBmb3IgKDsgKyt4Y1stLXNkXSA+IDk7KSB7XHJcbiAgICAgICAgeGNbc2RdID0gMDtcclxuICAgICAgICBpZiAoc2QgPT09IDApIHtcclxuICAgICAgICAgICsreC5lO1xyXG4gICAgICAgICAgeGMudW5zaGlmdCgxKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoc2QgPSB4Yy5sZW5ndGg7ICF4Y1stLXNkXTspIHhjLnBvcCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWcgeCBpbiBub3JtYWwgb3IgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqIEhhbmRsZXMgUC50b0V4cG9uZW50aWFsLCBQLnRvRml4ZWQsIFAudG9KU09OLCBQLnRvUHJlY2lzaW9uLCBQLnRvU3RyaW5nIGFuZCBQLnZhbHVlT2YuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnkoeCwgZG9FeHBvbmVudGlhbCwgaXNOb256ZXJvKSB7XHJcbiAgdmFyIGUgPSB4LmUsXHJcbiAgICBzID0geC5jLmpvaW4oJycpLFxyXG4gICAgbiA9IHMubGVuZ3RoO1xyXG5cclxuICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbj9cclxuICBpZiAoZG9FeHBvbmVudGlhbCkge1xyXG4gICAgcyA9IHMuY2hhckF0KDApICsgKG4gPiAxID8gJy4nICsgcy5zbGljZSgxKSA6ICcnKSArIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuXHJcbiAgLy8gTm9ybWFsIG5vdGF0aW9uLlxyXG4gIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuICAgIGZvciAoOyArK2U7KSBzID0gJzAnICsgcztcclxuICAgIHMgPSAnMC4nICsgcztcclxuICB9IGVsc2UgaWYgKGUgPiAwKSB7XHJcbiAgICBpZiAoKytlID4gbikge1xyXG4gICAgICBmb3IgKGUgLT0gbjsgZS0tOykgcyArPSAnMCc7XHJcbiAgICB9IGVsc2UgaWYgKGUgPCBuKSB7XHJcbiAgICAgIHMgPSBzLnNsaWNlKDAsIGUpICsgJy4nICsgcy5zbGljZShlKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKG4gPiAxKSB7XHJcbiAgICBzID0gcy5jaGFyQXQoMCkgKyAnLicgKyBzLnNsaWNlKDEpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHgucyA8IDAgJiYgaXNOb256ZXJvID8gJy0nICsgcyA6IHM7XHJcbn1cclxuXHJcblxyXG4vLyBQcm90b3R5cGUvaW5zdGFuY2UgbWV0aG9kc1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnLlxyXG4gKi9cclxuUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcclxuICB4LnMgPSAxO1xyXG4gIHJldHVybiB4O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LFxyXG4gKiAgICAgICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3JcclxuICogICAgICAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLlxyXG4gKi9cclxuUC5jbXAgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBpc25lZyxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgeGMgPSB4LmMsXHJcbiAgICB5YyA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmMsXHJcbiAgICBpID0geC5zLFxyXG4gICAgaiA9IHkucyxcclxuICAgIGsgPSB4LmUsXHJcbiAgICBsID0geS5lO1xyXG5cclxuICAvLyBFaXRoZXIgemVybz9cclxuICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuICF4Y1swXSA/ICF5Y1swXSA/IDAgOiAtaiA6IGk7XHJcblxyXG4gIC8vIFNpZ25zIGRpZmZlcj9cclxuICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgaXNuZWcgPSBpIDwgMDtcclxuXHJcbiAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgaWYgKGsgIT0gbCkgcmV0dXJuIGsgPiBsIF4gaXNuZWcgPyAxIDogLTE7XHJcblxyXG4gIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICBmb3IgKGkgPSAtMTsgKytpIDwgajspIHtcclxuICAgIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBpc25lZyA/IDEgOiAtMTtcclxuICB9XHJcblxyXG4gIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gaXNuZWcgPyAxIDogLTE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2YgQmlnIHksIHJvdW5kZWQsXHJcbiAqIGlmIG5lY2Vzc2FyeSwgdG8gYSBtYXhpbXVtIG9mIEJpZy5EUCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIEJpZy5STS5cclxuICovXHJcblAuZGl2ID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgYSA9IHguYywgICAgICAgICAgICAgICAgICAvLyBkaXZpZGVuZFxyXG4gICAgYiA9ICh5ID0gbmV3IEJpZyh5KSkuYywgICAvLyBkaXZpc29yXHJcbiAgICBrID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgIGRwID0gQmlnLkRQO1xyXG5cclxuICBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAwIHx8IGRwID4gTUFYX0RQKSB7XHJcbiAgICB0aHJvdyBFcnJvcihJTlZBTElEX0RQKTtcclxuICB9XHJcblxyXG4gIC8vIERpdmlzb3IgaXMgemVybz9cclxuICBpZiAoIWJbMF0pIHtcclxuICAgIHRocm93IEVycm9yKERJVl9CWV9aRVJPKTtcclxuICB9XHJcblxyXG4gIC8vIERpdmlkZW5kIGlzIDA/IFJldHVybiArLTAuXHJcbiAgaWYgKCFhWzBdKSB7XHJcbiAgICB5LnMgPSBrO1xyXG4gICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgcmV0dXJuIHk7XHJcbiAgfVxyXG5cclxuICB2YXIgYmwsIGJ0LCBuLCBjbXAsIHJpLFxyXG4gICAgYnogPSBiLnNsaWNlKCksXHJcbiAgICBhaSA9IGJsID0gYi5sZW5ndGgsXHJcbiAgICBhbCA9IGEubGVuZ3RoLFxyXG4gICAgciA9IGEuc2xpY2UoMCwgYmwpLCAgIC8vIHJlbWFpbmRlclxyXG4gICAgcmwgPSByLmxlbmd0aCxcclxuICAgIHEgPSB5LCAgICAgICAgICAgICAgICAvLyBxdW90aWVudFxyXG4gICAgcWMgPSBxLmMgPSBbXSxcclxuICAgIHFpID0gMCxcclxuICAgIHAgPSBkcCArIChxLmUgPSB4LmUgLSB5LmUpICsgMTsgICAgLy8gcHJlY2lzaW9uIG9mIHRoZSByZXN1bHRcclxuXHJcbiAgcS5zID0gaztcclxuICBrID0gcCA8IDAgPyAwIDogcDtcclxuXHJcbiAgLy8gQ3JlYXRlIHZlcnNpb24gb2YgZGl2aXNvciB3aXRoIGxlYWRpbmcgemVyby5cclxuICBiei51bnNoaWZ0KDApO1xyXG5cclxuICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gIGZvciAoOyBybCsrIDwgYmw7KSByLnB1c2goMCk7XHJcblxyXG4gIGRvIHtcclxuXHJcbiAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgIGZvciAobiA9IDA7IG4gPCAxMDsgbisrKSB7XHJcblxyXG4gICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgaWYgKGJsICE9IChybCA9IHIubGVuZ3RoKSkge1xyXG4gICAgICAgIGNtcCA9IGJsID4gcmwgPyAxIDogLTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yIChyaSA9IC0xLCBjbXAgPSAwOyArK3JpIDwgYmw7KSB7XHJcbiAgICAgICAgICBpZiAoYltyaV0gIT0gcltyaV0pIHtcclxuICAgICAgICAgICAgY21wID0gYltyaV0gPiByW3JpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAvLyBSZW1haW5kZXIgY2FuJ3QgYmUgbW9yZSB0aGFuIDEgZGlnaXQgbG9uZ2VyIHRoYW4gZGl2aXNvci5cclxuICAgICAgICAvLyBFcXVhbGlzZSBsZW5ndGhzIHVzaW5nIGRpdmlzb3Igd2l0aCBleHRyYSBsZWFkaW5nIHplcm8/XHJcbiAgICAgICAgZm9yIChidCA9IHJsID09IGJsID8gYiA6IGJ6OyBybDspIHtcclxuICAgICAgICAgIGlmIChyWy0tcmxdIDwgYnRbcmxdKSB7XHJcbiAgICAgICAgICAgIHJpID0gcmw7XHJcbiAgICAgICAgICAgIGZvciAoOyByaSAmJiAhclstLXJpXTspIHJbcmldID0gOTtcclxuICAgICAgICAgICAgLS1yW3JpXTtcclxuICAgICAgICAgICAgcltybF0gKz0gMTA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByW3JsXSAtPSBidFtybF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKDsgIXJbMF07KSByLnNoaWZ0KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIGRpZ2l0IG4gdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgIHFjW3FpKytdID0gY21wID8gbiA6ICsrbjtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgIGlmIChyWzBdICYmIGNtcCkgcltybF0gPSBhW2FpXSB8fCAwO1xyXG4gICAgZWxzZSByID0gW2FbYWldXTtcclxuXHJcbiAgfSB3aGlsZSAoKGFpKysgPCBhbCB8fCByWzBdICE9PSBVTkRFRklORUQpICYmIGstLSk7XHJcblxyXG4gIC8vIExlYWRpbmcgemVybz8gRG8gbm90IHJlbW92ZSBpZiByZXN1bHQgaXMgc2ltcGx5IHplcm8gKHFpID09IDEpLlxyXG4gIGlmICghcWNbMF0gJiYgcWkgIT0gMSkge1xyXG5cclxuICAgIC8vIFRoZXJlIGNhbid0IGJlIG1vcmUgdGhhbiBvbmUgemVyby5cclxuICAgIHFjLnNoaWZ0KCk7XHJcbiAgICBxLmUtLTtcclxuICAgIHAtLTtcclxuICB9XHJcblxyXG4gIC8vIFJvdW5kP1xyXG4gIGlmIChxaSA+IHApIHJvdW5kKHEsIHAsIEJpZy5STSwgclswXSAhPT0gVU5ERUZJTkVEKTtcclxuXHJcbiAgcmV0dXJuIHE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICovXHJcblAuZXEgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA9PT0gMDtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3RoZXJ3aXNlIHJldHVyblxyXG4gKiBmYWxzZS5cclxuICovXHJcblAuZ3QgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZVxyXG4gKiByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5QLmd0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgcmV0dXJuIHRoaXMuY21wKHkpID4gLTE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqL1xyXG5QLmx0ID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPCAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2VcclxuICogcmV0dXJuIGZhbHNlLlxyXG4gKi9cclxuUC5sdGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgbWludXMgdGhlIHZhbHVlIG9mIEJpZyB5LlxyXG4gKi9cclxuUC5taW51cyA9IFAuc3ViID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgaSwgaiwgdCwgeGx0eSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIGEgPSB4LnMsXHJcbiAgICBiID0gKHkgPSBuZXcgQmlnKHkpKS5zO1xyXG5cclxuICAvLyBTaWducyBkaWZmZXI/XHJcbiAgaWYgKGEgIT0gYikge1xyXG4gICAgeS5zID0gLWI7XHJcbiAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHhjID0geC5jLnNsaWNlKCksXHJcbiAgICB4ZSA9IHguZSxcclxuICAgIHljID0geS5jLFxyXG4gICAgeWUgPSB5LmU7XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcbiAgICBpZiAoeWNbMF0pIHtcclxuICAgICAgeS5zID0gLWI7XHJcbiAgICB9IGVsc2UgaWYgKHhjWzBdKSB7XHJcbiAgICAgIHkgPSBuZXcgQmlnKHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeS5zID0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB5O1xyXG4gIH1cclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLiBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICBpZiAoeGx0eSA9IGEgPCAwKSB7XHJcbiAgICAgIGEgPSAtYTtcclxuICAgICAgdCA9IHhjO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeWUgPSB4ZTtcclxuICAgICAgdCA9IHljO1xyXG4gICAgfVxyXG5cclxuICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgZm9yIChiID0gYTsgYi0tOykgdC5wdXNoKDApO1xyXG4gICAgdC5yZXZlcnNlKCk7XHJcbiAgfSBlbHNlIHtcclxuXHJcbiAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgaiA9ICgoeGx0eSA9IHhjLmxlbmd0aCA8IHljLmxlbmd0aCkgPyB4YyA6IHljKS5sZW5ndGg7XHJcblxyXG4gICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgeGx0eSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgaWYgKHhsdHkpIHtcclxuICAgIHQgPSB4YztcclxuICAgIHhjID0geWM7XHJcbiAgICB5YyA9IHQ7XHJcbiAgICB5LnMgPSAteS5zO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci4gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdGlvbiBvbmx5XHJcbiAgICogbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAqL1xyXG4gIGlmICgoYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKSkgPiAwKSBmb3IgKDsgYi0tOykgeGNbaSsrXSA9IDA7XHJcblxyXG4gIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgZm9yIChiID0gaTsgaiA+IGE7KSB7XHJcbiAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07KSB4Y1tpXSA9IDk7XHJcbiAgICAgIC0teGNbaV07XHJcbiAgICAgIHhjW2pdICs9IDEwO1xyXG4gICAgfVxyXG5cclxuICAgIHhjW2pdIC09IHljW2pdO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoOyB4Y1stLWJdID09PSAwOykgeGMucG9wKCk7XHJcblxyXG4gIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgZm9yICg7IHhjWzBdID09PSAwOykge1xyXG4gICAgeGMuc2hpZnQoKTtcclxuICAgIC0teWU7XHJcbiAgfVxyXG5cclxuICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgLy8gbiAtIG4gPSArMFxyXG4gICAgeS5zID0gMTtcclxuXHJcbiAgICAvLyBSZXN1bHQgbXVzdCBiZSB6ZXJvLlxyXG4gICAgeGMgPSBbeWUgPSAwXTtcclxuICB9XHJcblxyXG4gIHkuYyA9IHhjO1xyXG4gIHkuZSA9IHllO1xyXG5cclxuICByZXR1cm4geTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBtb2R1bG8gdGhlIHZhbHVlIG9mIEJpZyB5LlxyXG4gKi9cclxuUC5tb2QgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciB5Z3R4LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgYSA9IHgucyxcclxuICAgIGIgPSAoeSA9IG5ldyBCaWcoeSkpLnM7XHJcblxyXG4gIGlmICgheS5jWzBdKSB7XHJcbiAgICB0aHJvdyBFcnJvcihESVZfQllfWkVSTyk7XHJcbiAgfVxyXG5cclxuICB4LnMgPSB5LnMgPSAxO1xyXG4gIHlndHggPSB5LmNtcCh4KSA9PSAxO1xyXG4gIHgucyA9IGE7XHJcbiAgeS5zID0gYjtcclxuXHJcbiAgaWYgKHlndHgpIHJldHVybiBuZXcgQmlnKHgpO1xyXG5cclxuICBhID0gQmlnLkRQO1xyXG4gIGIgPSBCaWcuUk07XHJcbiAgQmlnLkRQID0gQmlnLlJNID0gMDtcclxuICB4ID0geC5kaXYoeSk7XHJcbiAgQmlnLkRQID0gYTtcclxuICBCaWcuUk0gPSBiO1xyXG5cclxuICByZXR1cm4gdGhpcy5taW51cyh4LnRpbWVzKHkpKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBuZWdhdGVkLlxyXG4gKi9cclxuUC5uZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcclxuICB4LnMgPSAteC5zO1xyXG4gIHJldHVybiB4O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHBsdXMgdGhlIHZhbHVlIG9mIEJpZyB5LlxyXG4gKi9cclxuUC5wbHVzID0gUC5hZGQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBlLCBrLCB0LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICB5ID0gbmV3IEJpZyh5KTtcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmICh4LnMgIT0geS5zKSB7XHJcbiAgICB5LnMgPSAteS5zO1xyXG4gICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgfVxyXG5cclxuICB2YXIgeGUgPSB4LmUsXHJcbiAgICB4YyA9IHguYyxcclxuICAgIHllID0geS5lLFxyXG4gICAgeWMgPSB5LmM7XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcbiAgICBpZiAoIXljWzBdKSB7XHJcbiAgICAgIGlmICh4Y1swXSkge1xyXG4gICAgICAgIHkgPSBuZXcgQmlnKHgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHkucyA9IHgucztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfVxyXG5cclxuICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gIC8vIE5vdGU6IHJldmVyc2UgZmFzdGVyIHRoYW4gdW5zaGlmdHMuXHJcbiAgaWYgKGUgPSB4ZSAtIHllKSB7XHJcbiAgICBpZiAoZSA+IDApIHtcclxuICAgICAgeWUgPSB4ZTtcclxuICAgICAgdCA9IHljO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZSA9IC1lO1xyXG4gICAgICB0ID0geGM7XHJcbiAgICB9XHJcblxyXG4gICAgdC5yZXZlcnNlKCk7XHJcbiAgICBmb3IgKDsgZS0tOykgdC5wdXNoKDApO1xyXG4gICAgdC5yZXZlcnNlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LlxyXG4gIGlmICh4Yy5sZW5ndGggLSB5Yy5sZW5ndGggPCAwKSB7XHJcbiAgICB0ID0geWM7XHJcbiAgICB5YyA9IHhjO1xyXG4gICAgeGMgPSB0O1xyXG4gIH1cclxuXHJcbiAgZSA9IHljLmxlbmd0aDtcclxuXHJcbiAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGxlZnQgYXMgdGhleSBhcmUuXHJcbiAgZm9yIChrID0gMDsgZTsgeGNbZV0gJT0gMTApIGsgPSAoeGNbLS1lXSA9IHhjW2VdICsgeWNbZV0gKyBrKSAvIDEwIHwgMDtcclxuXHJcbiAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG5cclxuICBpZiAoaykge1xyXG4gICAgeGMudW5zaGlmdChrKTtcclxuICAgICsreWU7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChlID0geGMubGVuZ3RoOyB4Y1stLWVdID09PSAwOykgeGMucG9wKCk7XHJcblxyXG4gIHkuYyA9IHhjO1xyXG4gIHkuZSA9IHllO1xyXG5cclxuICByZXR1cm4geTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHJhaXNlZCB0byB0aGUgcG93ZXIgbi5cclxuICogSWYgbiBpcyBuZWdhdGl2ZSwgcm91bmQgdG8gYSBtYXhpbXVtIG9mIEJpZy5EUCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZ1xyXG4gKiBtb2RlIEJpZy5STS5cclxuICpcclxuICogbiB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1BPV0VSIHRvIE1BWF9QT1dFUiBpbmNsdXNpdmUuXHJcbiAqL1xyXG5QLnBvdyA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgb25lID0gbmV3IHguY29uc3RydWN0b3IoJzEnKSxcclxuICAgIHkgPSBvbmUsXHJcbiAgICBpc25lZyA9IG4gPCAwO1xyXG5cclxuICBpZiAobiAhPT0gfn5uIHx8IG4gPCAtTUFYX1BPV0VSIHx8IG4gPiBNQVhfUE9XRVIpIHtcclxuICAgIHRocm93IEVycm9yKElOVkFMSUQgKyAnZXhwb25lbnQnKTtcclxuICB9XHJcblxyXG4gIGlmIChpc25lZykgbiA9IC1uO1xyXG5cclxuICBmb3IgKDs7KSB7XHJcbiAgICBpZiAobiAmIDEpIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgbiA+Pj0gMTtcclxuICAgIGlmICghbikgYnJlYWs7XHJcbiAgICB4ID0geC50aW1lcyh4KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBpc25lZyA/IG9uZS5kaXYoeSkgOiB5O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHJvdW5kZWQgdG8gYSBtYXhpbXVtIHByZWNpc2lvbiBvZiBzZFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgQmlnLlJNIGlmIHJtIGlzIG5vdCBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIHNkIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybT8ge251bWJlcn0gUm91bmRpbmcgbW9kZTogMCAoZG93biksIDEgKGhhbGYtdXApLCAyIChoYWxmLWV2ZW4pIG9yIDMgKHVwKS5cclxuICovXHJcblAucHJlYyA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICBpZiAoc2QgIT09IH5+c2QgfHwgc2QgPCAxIHx8IHNkID4gTUFYX0RQKSB7XHJcbiAgICB0aHJvdyBFcnJvcihJTlZBTElEICsgJ3ByZWNpc2lvbicpO1xyXG4gIH1cclxuICByZXR1cm4gcm91bmQobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHNkLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXNcclxuICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgQmlnLlJNIGlmIHJtIGlzIG5vdCBzcGVjaWZpZWQuXHJcbiAqIElmIGRwIGlzIG5lZ2F0aXZlLCByb3VuZCB0byBhbiBpbnRlZ2VyIHdoaWNoIGlzIGEgbXVsdGlwbGUgb2YgMTAqKi1kcC5cclxuICogSWYgZHAgaXMgbm90IHNwZWNpZmllZCwgcm91bmQgdG8gMCBkZWNpbWFsIHBsYWNlcy5cclxuICpcclxuICogZHA/IHtudW1iZXJ9IEludGVnZXIsIC1NQVhfRFAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICogcm0/IHtudW1iZXJ9IFJvdW5kaW5nIG1vZGU6IDAgKGRvd24pLCAxIChoYWxmLXVwKSwgMiAoaGFsZi1ldmVuKSBvciAzICh1cCkuXHJcbiAqL1xyXG5QLnJvdW5kID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gIGlmIChkcCA9PT0gVU5ERUZJTkVEKSBkcCA9IDA7XHJcbiAgZWxzZSBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAtTUFYX0RQIHx8IGRwID4gTUFYX0RQKSB7XHJcbiAgICB0aHJvdyBFcnJvcihJTlZBTElEX0RQKTtcclxuICB9XHJcbiAgcmV0dXJuIHJvdW5kKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCBkcCArIHRoaXMuZSArIDEsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcsIHJvdW5kZWQsIGlmXHJcbiAqIG5lY2Vzc2FyeSwgdG8gYSBtYXhpbXVtIG9mIEJpZy5EUCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIEJpZy5STS5cclxuICovXHJcblAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgciwgYywgdCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHMgPSB4LnMsXHJcbiAgICBlID0geC5lLFxyXG4gICAgaGFsZiA9IG5ldyBCaWcoJzAuNScpO1xyXG5cclxuICAvLyBaZXJvP1xyXG4gIGlmICgheC5jWzBdKSByZXR1cm4gbmV3IEJpZyh4KTtcclxuXHJcbiAgLy8gTmVnYXRpdmU/XHJcbiAgaWYgKHMgPCAwKSB7XHJcbiAgICB0aHJvdyBFcnJvcihOQU1FICsgJ05vIHNxdWFyZSByb290Jyk7XHJcbiAgfVxyXG5cclxuICAvLyBFc3RpbWF0ZS5cclxuICBzID0gTWF0aC5zcXJ0KCtzdHJpbmdpZnkoeCwgdHJ1ZSwgdHJ1ZSkpO1xyXG5cclxuICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gIC8vIFJlLWVzdGltYXRlOiBwYXNzIHggY29lZmZpY2llbnQgdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSByZXN1bHQgZXhwb25lbnQuXHJcbiAgaWYgKHMgPT09IDAgfHwgcyA9PT0gMSAvIDApIHtcclxuICAgIGMgPSB4LmMuam9pbignJyk7XHJcbiAgICBpZiAoIShjLmxlbmd0aCArIGUgJiAxKSkgYyArPSAnMCc7XHJcbiAgICBzID0gTWF0aC5zcXJ0KGMpO1xyXG4gICAgZSA9ICgoZSArIDEpIC8gMiB8IDApIC0gKGUgPCAwIHx8IGUgJiAxKTtcclxuICAgIHIgPSBuZXcgQmlnKChzID09IDEgLyAwID8gJzVlJyA6IChzID0gcy50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsIHMuaW5kZXhPZignZScpICsgMSkpICsgZSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHIgPSBuZXcgQmlnKHMgKyAnJyk7XHJcbiAgfVxyXG5cclxuICBlID0gci5lICsgKEJpZy5EUCArPSA0KTtcclxuXHJcbiAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gIGRvIHtcclxuICAgIHQgPSByO1xyXG4gICAgciA9IGhhbGYudGltZXModC5wbHVzKHguZGl2KHQpKSk7XHJcbiAgfSB3aGlsZSAodC5jLnNsaWNlKDAsIGUpLmpvaW4oJycpICE9PSByLmMuc2xpY2UoMCwgZSkuam9pbignJykpO1xyXG5cclxuICByZXR1cm4gcm91bmQociwgKEJpZy5EUCAtPSA0KSArIHIuZSArIDEsIEJpZy5STSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgdGltZXMgdGhlIHZhbHVlIG9mIEJpZyB5LlxyXG4gKi9cclxuUC50aW1lcyA9IFAubXVsID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgYyxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHhjID0geC5jLFxyXG4gICAgeWMgPSAoeSA9IG5ldyBCaWcoeSkpLmMsXHJcbiAgICBhID0geGMubGVuZ3RoLFxyXG4gICAgYiA9IHljLmxlbmd0aCxcclxuICAgIGkgPSB4LmUsXHJcbiAgICBqID0geS5lO1xyXG5cclxuICAvLyBEZXRlcm1pbmUgc2lnbiBvZiByZXN1bHQuXHJcbiAgeS5zID0geC5zID09IHkucyA/IDEgOiAtMTtcclxuXHJcbiAgLy8gUmV0dXJuIHNpZ25lZCAwIGlmIGVpdGhlciAwLlxyXG4gIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcbiAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICByZXR1cm4geTtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpc2UgZXhwb25lbnQgb2YgcmVzdWx0IGFzIHguZSArIHkuZS5cclxuICB5LmUgPSBpICsgajtcclxuXHJcbiAgLy8gSWYgYXJyYXkgeGMgaGFzIGZld2VyIGRpZ2l0cyB0aGFuIHljLCBzd2FwIHhjIGFuZCB5YywgYW5kIGxlbmd0aHMuXHJcbiAgaWYgKGEgPCBiKSB7XHJcbiAgICBjID0geGM7XHJcbiAgICB4YyA9IHljO1xyXG4gICAgeWMgPSBjO1xyXG4gICAgaiA9IGE7XHJcbiAgICBhID0gYjtcclxuICAgIGIgPSBqO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGlzZSBjb2VmZmljaWVudCBhcnJheSBvZiByZXN1bHQgd2l0aCB6ZXJvcy5cclxuICBmb3IgKGMgPSBuZXcgQXJyYXkoaiA9IGEgKyBiKTsgai0tOykgY1tqXSA9IDA7XHJcblxyXG4gIC8vIE11bHRpcGx5LlxyXG5cclxuICAvLyBpIGlzIGluaXRpYWxseSB4Yy5sZW5ndGguXHJcbiAgZm9yIChpID0gYjsgaS0tOykge1xyXG4gICAgYiA9IDA7XHJcblxyXG4gICAgLy8gYSBpcyB5Yy5sZW5ndGguXHJcbiAgICBmb3IgKGogPSBhICsgaTsgaiA+IGk7KSB7XHJcblxyXG4gICAgICAvLyBDdXJyZW50IHN1bSBvZiBwcm9kdWN0cyBhdCB0aGlzIGRpZ2l0IHBvc2l0aW9uLCBwbHVzIGNhcnJ5LlxyXG4gICAgICBiID0gY1tqXSArIHljW2ldICogeGNbaiAtIGkgLSAxXSArIGI7XHJcbiAgICAgIGNbai0tXSA9IGIgJSAxMDtcclxuXHJcbiAgICAgIC8vIGNhcnJ5XHJcbiAgICAgIGIgPSBiIC8gMTAgfCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGNbal0gPSBiO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5jcmVtZW50IHJlc3VsdCBleHBvbmVudCBpZiB0aGVyZSBpcyBhIGZpbmFsIGNhcnJ5LCBvdGhlcndpc2UgcmVtb3ZlIGxlYWRpbmcgemVyby5cclxuICBpZiAoYikgKyt5LmU7XHJcbiAgZWxzZSBjLnNoaWZ0KCk7XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKGkgPSBjLmxlbmd0aDsgIWNbLS1pXTspIGMucG9wKCk7XHJcbiAgeS5jID0gYztcclxuXHJcbiAgcmV0dXJuIHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gcm91bmRlZCB0byBkcCBmaXhlZFxyXG4gKiBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBCaWcuUk0gaWYgcm0gaXMgbm90IHNwZWNpZmllZC5cclxuICpcclxuICogZHA/IHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAqIHJtPyB7bnVtYmVyfSBSb3VuZGluZyBtb2RlOiAwIChkb3duKSwgMSAoaGFsZi11cCksIDIgKGhhbGYtZXZlbikgb3IgMyAodXApLlxyXG4gKi9cclxuUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIG4gPSB4LmNbMF07XHJcblxyXG4gIGlmIChkcCAhPT0gVU5ERUZJTkVEKSB7XHJcbiAgICBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAwIHx8IGRwID4gTUFYX0RQKSB7XHJcbiAgICAgIHRocm93IEVycm9yKElOVkFMSURfRFApO1xyXG4gICAgfVxyXG4gICAgeCA9IHJvdW5kKG5ldyB4LmNvbnN0cnVjdG9yKHgpLCArK2RwLCBybSk7XHJcbiAgICBmb3IgKDsgeC5jLmxlbmd0aCA8IGRwOykgeC5jLnB1c2goMCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaW5naWZ5KHgsIHRydWUsICEhbik7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaW4gbm9ybWFsIG5vdGF0aW9uIHJvdW5kZWQgdG8gZHAgZml4ZWRcclxuICogZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgQmlnLlJNIGlmIHJtIGlzIG5vdCBzcGVjaWZpZWQuXHJcbiAqXHJcbiAqIGRwPyB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gKiBybT8ge251bWJlcn0gUm91bmRpbmcgbW9kZTogMCAoZG93biksIDEgKGhhbGYtdXApLCAyIChoYWxmLWV2ZW4pIG9yIDMgKHVwKS5cclxuICpcclxuICogKC0wKS50b0ZpeGVkKDApIGlzICcwJywgYnV0ICgtMC4xKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAqICgtMCkudG9GaXhlZCgxKSBpcyAnMC4wJywgYnV0ICgtMC4wMSkudG9GaXhlZCgxKSBpcyAnLTAuMCcuXHJcbiAqL1xyXG5QLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgbiA9IHguY1swXTtcclxuXHJcbiAgaWYgKGRwICE9PSBVTkRFRklORUQpIHtcclxuICAgIGlmIChkcCAhPT0gfn5kcCB8fCBkcCA8IDAgfHwgZHAgPiBNQVhfRFApIHtcclxuICAgICAgdGhyb3cgRXJyb3IoSU5WQUxJRF9EUCk7XHJcbiAgICB9XHJcbiAgICB4ID0gcm91bmQobmV3IHguY29uc3RydWN0b3IoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG5cclxuICAgIC8vIHguZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSBpcyByb3VuZGVkIHVwLlxyXG4gICAgZm9yIChkcCA9IGRwICsgeC5lICsgMTsgeC5jLmxlbmd0aCA8IGRwOykgeC5jLnB1c2goMCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaW5naWZ5KHgsIGZhbHNlLCAhIW4pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnLlxyXG4gKiBSZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhpcyBCaWcgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXHJcbiAqIEJpZy5QRSwgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW4gQmlnLk5FLlxyXG4gKiBPbWl0IHRoZSBzaWduIGZvciBuZWdhdGl2ZSB6ZXJvLlxyXG4gKi9cclxuUFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IFAudG9KU09OID0gUC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBCaWcgPSB4LmNvbnN0cnVjdG9yO1xyXG4gIHJldHVybiBzdHJpbmdpZnkoeCwgeC5lIDw9IEJpZy5ORSB8fCB4LmUgPj0gQmlnLlBFLCAhIXguY1swXSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBhcyBhIHByaW1pdHZlIG51bWJlci5cclxuICovXHJcblAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG4gPSArc3RyaW5naWZ5KHRoaXMsIHRydWUsIHRydWUpO1xyXG4gIGlmICh0aGlzLmNvbnN0cnVjdG9yLnN0cmljdCA9PT0gdHJ1ZSAmJiAhdGhpcy5lcShuLnRvU3RyaW5nKCkpKSB7XHJcbiAgICB0aHJvdyBFcnJvcihOQU1FICsgJ0ltcHJlY2lzZSBjb252ZXJzaW9uJyk7XHJcbiAgfVxyXG4gIHJldHVybiBuO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nXHJcbiAqIHJvdW5kaW5nIG1vZGUgcm0sIG9yIEJpZy5STSBpZiBybSBpcyBub3Qgc3BlY2lmaWVkLlxyXG4gKiBVc2UgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgc2QgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnRcclxuICogdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gbm9ybWFsIG5vdGF0aW9uLlxyXG4gKlxyXG4gKiBzZCB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICogcm0/IHtudW1iZXJ9IFJvdW5kaW5nIG1vZGU6IDAgKGRvd24pLCAxIChoYWxmLXVwKSwgMiAoaGFsZi1ldmVuKSBvciAzICh1cCkuXHJcbiAqL1xyXG5QLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICBuID0geC5jWzBdO1xyXG5cclxuICBpZiAoc2QgIT09IFVOREVGSU5FRCkge1xyXG4gICAgaWYgKHNkICE9PSB+fnNkIHx8IHNkIDwgMSB8fCBzZCA+IE1BWF9EUCkge1xyXG4gICAgICB0aHJvdyBFcnJvcihJTlZBTElEICsgJ3ByZWNpc2lvbicpO1xyXG4gICAgfVxyXG4gICAgeCA9IHJvdW5kKG5ldyBCaWcoeCksIHNkLCBybSk7XHJcbiAgICBmb3IgKDsgeC5jLmxlbmd0aCA8IHNkOykgeC5jLnB1c2goMCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaW5naWZ5KHgsIHNkIDw9IHguZSB8fCB4LmUgPD0gQmlnLk5FIHx8IHguZSA+PSBCaWcuUEUsICEhbik7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcuXHJcbiAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGlzIEJpZyBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBncmVhdGVyIHRoYW5cclxuICogQmlnLlBFLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhbiBCaWcuTkUuXHJcbiAqIEluY2x1ZGUgdGhlIHNpZ24gZm9yIG5lZ2F0aXZlIHplcm8uXHJcbiAqL1xyXG5QLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQmlnID0geC5jb25zdHJ1Y3RvcjtcclxuICBpZiAoQmlnLnN0cmljdCA9PT0gdHJ1ZSkge1xyXG4gICAgdGhyb3cgRXJyb3IoTkFNRSArICd2YWx1ZU9mIGRpc2FsbG93ZWQnKTtcclxuICB9XHJcbiAgcmV0dXJuIHN0cmluZ2lmeSh4LCB4LmUgPD0gQmlnLk5FIHx8IHguZSA+PSBCaWcuUEUsIHRydWUpO1xyXG59O1xyXG5cclxuXHJcbi8vIEV4cG9ydFxyXG5cclxuXHJcbmV4cG9ydCB2YXIgQmlnID0gX0JpZ18oKTtcclxuXHJcbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0RlZmluaXRlbHlUeXBlZC9EZWZpbml0ZWx5VHlwZWQvbWFzdGVyL3R5cGVzL2JpZy5qcy9pbmRleC5kLnRzXCIgLz5cclxuZXhwb3J0IGRlZmF1bHQgQmlnO1xyXG4iXSwibmFtZXMiOlsiRFAiLCJSTSIsIk1BWF9EUCIsIk1BWF9QT1dFUiIsIk5FIiwiUEUiLCJTVFJJQ1QiLCJOQU1FIiwiSU5WQUxJRCIsIklOVkFMSURfRFAiLCJJTlZBTElEX1JNIiwiRElWX0JZX1pFUk8iLCJQIiwiVU5ERUZJTkVEIiwiTlVNRVJJQyIsIl9CaWdfIiwiQmlnIiwibiIsIngiLCJzIiwiZSIsImMiLCJzbGljZSIsInN0cmljdCIsIlR5cGVFcnJvciIsIlN0cmluZyIsInBhcnNlIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJyb3VuZERvd24iLCJyb3VuZEhhbGZVcCIsInJvdW5kSGFsZkV2ZW4iLCJyb3VuZFVwIiwiaSIsIm5sIiwidGVzdCIsIkVycm9yIiwiY2hhckF0IiwiaW5kZXhPZiIsInJlcGxhY2UiLCJzZWFyY2giLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJyb3VuZCIsInNkIiwicm0iLCJtb3JlIiwieGMiLCJ1bnNoaWZ0IiwicG9wIiwic3RyaW5naWZ5IiwiZG9FeHBvbmVudGlhbCIsImlzTm9uemVybyIsImpvaW4iLCJhYnMiLCJjbXAiLCJ5IiwiaXNuZWciLCJ5YyIsImoiLCJrIiwibCIsImRpdiIsImEiLCJiIiwiZHAiLCJibCIsImJ0IiwicmkiLCJieiIsImFpIiwiYWwiLCJyIiwicmwiLCJxIiwicWMiLCJxaSIsInAiLCJwdXNoIiwic2hpZnQiLCJlcSIsImd0IiwiZ3RlIiwibHQiLCJsdGUiLCJtaW51cyIsInN1YiIsInQiLCJ4bHR5IiwicGx1cyIsInhlIiwieWUiLCJyZXZlcnNlIiwibW9kIiwieWd0eCIsInRpbWVzIiwibmVnIiwiYWRkIiwicG93Iiwib25lIiwicHJlYyIsInNxcnQiLCJoYWxmIiwiTWF0aCIsInRvRXhwb25lbnRpYWwiLCJtdWwiLCJBcnJheSIsInRvRml4ZWQiLCJTeW1ib2wiLCJmb3IiLCJ0b0pTT04iLCJ0b1N0cmluZyIsInRvTnVtYmVyIiwidG9QcmVjaXNpb24iLCJ2YWx1ZU9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/big.js/big.mjs\n");

/***/ })

};
;